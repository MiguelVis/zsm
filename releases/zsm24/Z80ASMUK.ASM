;-----------------------------------------------;
;						;
;	Z80ASM - Z80 RESIDENT ASSEMBLER		;
;						;
;		Ver 2.4 			;
;						;
;	WRITTEN IN 8080 ASSEMBLY LANGUAGE	;
;	FOR ASSEMBLY BY THE CP/M ASSEMBLER	;
;						;
;-----------------------------------------------;
;
;-----------------------------------------------;
;						;
;	Original - LEHMAN CONSULTING SERVICES	;
;	(C) COPYRIGHT 1977			;
;						;
;	US User Group, Vol 16			;
;						;
;-----------------------------------------------;
;						;
;===============================================;
;						;
;	Modified by Ray Halls			;
;	August 1982				;
;	for CP/M Users Group (UK)		;
;						;
;	i) Correction to OP-CODE handling	;
;	ii) Addition of Consle Output and	;
;	    Print File for Listing pass		;
;	iii) Additional error reporting		;
;	iv) Expansion of DEFB facilities	;
;	v)  More comprehensive Relative dis-	;
;	   placement computation		;
;	vi) Accurate assembly of Labels		;
;	vii) Usigned 16-bit by 8-bit divide	;
;	   added to expression handling		;
;						;
;	October 1982				;
;						;
;	Bugs in NEG and I/O Opcode Routines	;
;	fixed.					;
;						;
;===============================================;
;
	ORG	100H
;
BEGIN:	JMP	Z80ASM		;CP/M ENTRY POINT BRANCH
;
;-----------------------------------------------;
;						;
;	CP/M 8080 UTILITY PACKAGE		;
;						;
;-----------------------------------------------;
;
;	
;-----------------------------------------------;
;						;
;	COMMUNICATIONS AREA			;
;						;
;-----------------------------------------------;
;
FCB1:	DB	0		;FILE CONTROL BLOCK (SOURCE)
	DS	32		;REMAINING AREA
FCB2:	DB	0		;FILE CONTROL BLOCK (HEX)
	DS	32
FCB3:	DB	0		;FILE CONTROL BLOCK (PRN)
	DS	32		;
IBP:	DS	2		;INPUT BUFFER POINTER (FCB1)
OBP:	DB	0		;OUTPUT BUFFER POINTER (FCB3)
OBP2:	DS	1		;OUTPUT BUFFER POINTER (FCB2)
IBUF:	DW	INBUF		;INPUT BUFFER ADDRESS
OBUF:	DW	OUTBUF		;OUTPUT BUFFER ADDRESS (FCB3)
OBUF2:	DW	OUTBF2		;OUTPUT BUFFER ADDRESS (FCB2)
INBUF:	DS	1024		;1K BUFFER FOR GNB (TO SPEED UP INPUT STREAM)
OUTBUF:	DS	128		;.PRN OUTPUT BUFFER
OUTBF2:	DS	128		;.HEX OUTPUT BUFFER
;
;	CP/M EQUATES
;
BDOS	EQU	5
BOOT	EQU	0
;
;
;	ENTRY - USED TO CALL BDOS - SAVES AND RESTORES REGISTERS
;
ENTRY	EQU	$
	PUSH B
	PUSH D
	PUSH H
	CALL	BDOS
	POP H
	POP D
	POP B
	RET
;
;	WLINE - WRITE LINE TO LIST DEVICE
;	HL -> BUFFER, TERM = 0AH
;
WLINE	EQU	$
	MOV A,M
	ANI 7FH		;MASK OFF TOP BIT
	MOV E,A
	MVI C,5
	CALL ENTRY
	MOV A,M
	CPI 0AH
	RZ
	INX H
	JMP WLINE
;
;	CLINE - WRITE LINE TO CONSOLE
;	HL -> BUFFER, TERM = 0AH
;
CLINE:	MOV A,M
	ANI 7FH		;MASK OFF TOP BIT
	MOV E,A
	MVI C,2H
	CALL ENTRY
	MOV A,M
	CPI 0AH
	RZ
	INX H
	JMP CLINE
;
;	WMSG - WRITE MESSAGE TO CONSOLE
;	DE -> MSG, TERM-'$'
;
WMSG	EQU	$
	MVI C,9
	CALL ENTRY
	RET
;
;	DSKSEL - SELECT DISK
;	DRIVE NUMBER IN A REG
;
DSKSEL	EQU	$
	MOV E,A
	MVI C,14
	CALL ENTRY
	RET
;
;	OPNFIL - OPEN FILE CONTROL BLOCK
;	REEL # AND NR ARE SET TO 00H
;	DE -> FCB
;	Z=0 SUCCESS, Z=1 FAILURE
;
OPNFIL	EQU	$
	PUSH H
	LXI H,12
	DAD D
	MVI M,0		;ZERO REEL #
	MVI C,15
	PUSH D
	CALL ENTRY
	POP D
	CPI 255
	POP H
	RZ
	PUSH H
	LXI H,32
	DAD D
	MVI M,0		; ZERO NR
	POP H
	RET
;
;	CLSFIL - CLOSE FILE CONTROL BLOCK
;	DE -> FCB
;	Z=0 SUCCESS, Z=1 ERROR
;
CLSFIL	EQU	$
	MVI C,16
	CALL ENTRY 
	CPI 255
	RET
;
;	DELFIL - DELETE FILE
;	DE -> FCB
;	Z=0 SUCCESS, Z=1 ERROR
;
DELFIL	EQU	$
	MVI C,19
	CALL ENTRY
	CPI 255
	RET
;
;	DREAD - READ DISK SECTOR
;	DE -> FCB
;	Z=0 ERROR OR EOF, Z=1 NORMAL
;
DREAD	EQU	$
	MVI C,20
	CALL ENTRY
	CPI 0
	RET
;
;	DWRITE - WRITE DISK SECTOR
;	DE -> FCB
;	Z=0 ERROR, Z=1 NORMAL
;
DWRITE	EQU	$
	MVI C,21
	CALL ENTRY
	CPI 0
	RET
;
;	CREFIL - CREATE FILE
;	REEL # ASSUMMED TO BE SET
;
;	DE -> FCB
;	Z=0 NORMAL, Z=1 ERROR
;
CREFIL	EQU	$
	MVI C,22
	CALL ENTRY
	CPI 255
	RET
;
;	DMASET - SET DMA ADDRESS
;	BUFFER ADDRESS IN DE
;
DMASET	EQU	$
	MVI C,26
	CALL ENTRY
	RET
;
;	MOVE (HL) <= (DE) LEN IN BC
;
MOVE	EQU	$
	XCHG
	MOV A,M
	STAX D
	INX H
	INX D 		;REPLACE 8 LINES BY EB,B0
	DCX B
	MOV A,B
	ORA C
	JNZ $-7 	;IF Z80 CPU
	XCHG		;PUT REGS BACK FOR CALLING ROUTINES SAKE
	RET
;
;	CMPCHR - COMPARE STRINGS (HL) : (DE) LEN IN B
;
CMPCHR	EQU	$
	PUSH H
	PUSH D
	PUSH B 		;SAVE REGS
	XCHG
CMPCH0:	LDAX D
	CALL CASCVRT	;CONVERT TO U/C
	CMP M
	JNZ CMPCH1
	INX H
	INX D
	DCR B
	JNZ CMPCH0
CMPCH1:	POP B
	POP D
	POP H 		;RESTORE REGS
	RET
;
;	CONVERTS L/C IN SOURCE TO U/C BUT LEAVES
;	COMMENTS AND MESSAGES ALONE
;
CASCVRT	EQU	$
	CPI 'a'
	RC
	CPI 7BH
	RNC
	ANI 5FH
	RET
;
;	DIVIDES 16-BIT DIVIDEND BY 8-BIT DIVISOR
;	ON ENTRY:  HL = DIVIDEND, E = DIVISOR
;	ON RETURN: HL = QUOTIENT.  REMAINDER DISCARDED
;
DIVIDE	EQU	$
	XRA A
	CMP E
	STC		;MARK 0 DIVISOR AS ERROR
	RZ		;..AND EXIT
	MVI D,16	;LOAD BIT COUNT
DIVID1:	DAD H
	RAL
	CMP E
	JC DIVID2
	SUB E
	INX H
DIVID2:	DCR D
	JNZ DIVID1
	XRA A		;ENSURE NO ERROR
	RET
;
;	MUL16 - HL <= HL * DE (16 BITS ONLY)
;
MUL16	EQU	$
	PUSH B
	PUSH D
	POP B
	PUSH D
	XCHG
	LXI H,0
MUL16A	EQU	$
	MOV A,C
	ORA B
	JNZ MUL16B
	POP D
	POP B
	RET
;
MUL16B:	DAD D
	DCX B
	JMP MUL16A
;
;	CMPHD - COMPARE HL:DE
;
CMPHD	EQU	$
	MOV A,H
	CMP D
	RNZ
	MOV A,L
	CMP E
	RET
;
;	GNB - GET NEXT BYTE (FCB1)
;
GNB	EQU	$
	PUSH H
	PUSH D
	LHLD IBP
	LXI D,INBUF+1024
	CALL CMPHD 	;SEE IF END OF BUFFER
	POP D
	POP H
	JNZ GNB0	;BRANCH IF NOT AT END OF BUFFER
	PUSH H
	PUSH D
	PUSH B		;GET 1K BLOCK FROM DISK
	LXI H,INBUF
	SHLD GNBPTR 	;SET UP POINTER FOR DMASET
	MVI B,8 	;NUMBER OF 128 BYTE SECTORS IN 1K BUFFER
GNB0A:	PUSH B
	LHLD GNBPTR
	XCHG
	CALL DMASET 	;SET UP DMA ADDRESS
	LXI D,FCB1
	CALL DREAD 	;GO READ A SECTOR
	LHLD GNBPTR
	LXI D,128
	DAD D
	SHLD GNBPTR 	;UPDATE POINTER
	POP B
	DCR B
	JNZ GNB0A 	;BRANCH BACK IF MORE TO DO
	POP B
	POP D 		;RESTORE REGS
	LXI H,INBUF
	SHLD IBP
	POP H 		;SET UP NEXT DATA POINTER
GNB0	EQU	$
	PUSH H
	LHLD IBP
	MOV A,M
	INX H
	SHLD IBP
	POP H 		;GET BYTE
	RET
;
GNBPTR:	DS	2	;TEMP POINTER FOR BUFFERING
;
;	WNB - WRITE NEXT BYTE (FCB3)
;	BYTE IN A REG
;
WNB	EQU	$
	PUSH H
	PUSH D
	PUSH PSW
	LDA OBP
	CPI 80H
	JNZ WNB0
	LXI D,OUTBUF
	CALL DMASET
	LXI D,FCB3
	CALL DWRITE
	JZ WNB00 	;BRANCH IF OK
	LXI D,WNBERR
	CALL WMSG
	JMP BOOT
;
WNB00	EQU	$
	XRA A
WNB0	EQU	$
	MOV E,A
	MVI D,0
	INR A
	STA OBP  
	LXI H,OUTBUF
	DAD D
	POP PSW
	MOV M,A
	POP D
	POP H
	RET
;
WNBERR:	DB	13,10,'OUTPUT FILE WRITE ERROR (DISK MAY BE FULL)',13,10,'$'
;
;	WNB2 - WRITE NEXT BYTE (FCB2)
;
WNB2	EQU	$
	PUSH H
	PUSH D
	PUSH PSW
	LDA OBP2
	CPI 80H
	JNZ WNB20
	LXI D,OUTBF2
	CALL DMASET
	LXI D,FCB2
	CALL DWRITE
	JZ WNB200 	;BRANCH IF ALL OK
	LXI D,WNBERR
	CALL WMSG
	JMP BOOT
;
WNB200	EQU	$
	XRA A
WNB20	EQU	$
	MOV E,A
	MVI D,0
	INR A
	STA OBP2
	LXI H,OUTBF2
	DAD D
	POP PSW
	MOV M,A 
	POP D
	POP H
	RET
;
;	CNV2HX - CONVERT CONTENTS OF A REG TO HEX CHARACTERS
;	AND PLACE IN BUFFER POINTED TO BY HL
;
CNV2HX	EQU	$
	PUSH B
	MOV B,A 
	RRC
	RRC
	RRC
	RRC
	ANI 0FH
	CALL CNV2H
	MOV A,B
	POP B
	ANI 0FH
CNV2H	EQU	$
	CPI 0AH
	JC CNV2H1
	ADI 7
CNV2H1:	ADI '0'
	MOV M,A
	INX H
	RET
;
;-----------------------------------------------;
;	COMMON DATA AREA (CDA)			;
;-----------------------------------------------;
;
	ORG	$+16 AND 0FFF0H ;MUST START ON 'LINE' BOUNDARY
;
HDRBUF:	DS	16	;MUST FOLLOW ORG    
REC:	DS	80H	;MUST FOLLOW HDRBUF
OBJ:	DS	32	;OBJECT CODE BUFFER
OBJCNT:	DS	1	;LEN OF DATA IN OBJ
INST:	DS	80H	;CURRENT INSTRUCTION (OR DATA FROM DB)
EOM:	DB	0	;END OF BUFFER CHARACTER (FOR WLINE)
IDBUF:	DS	16	;CURRENT ID
INTBUF:	DS	2	;RETURNED VALUE FROM INT ROUTINE
PC:	DS	2	;CURRENT PROGRAM COUNTER
LEN:	DS	1	;LEN OF CURRENT INSTRUCTION
LEN2:	DS	2	;FOR DEFS
VAL:	DS	2	;RETURN FROM EVAL ROUTINE
PTR1:	DS	2	;POINTS TO NEXT CHAR IN REC
PASSNO:	DS	1	;CURRENT PASS  0= PASS1   FF= PASS2
CURLNE:	DS	1	;CURRENT LINE NUMBER FOR PAGING OUTPUT
LBLADR:	DS	2	;LAST LBL ADDR IN SYM (FOR EQU)
EQUFLG:	DS	1	;IF NON-ZERO EQUVAL IS USED INSTEAD OF PC FOR PRINT 
EQUVAL:	DS	2	;VALUE OF LAST EQU
ENDADR:	DS	2	;EXPRESSION VALUE ON END STATEMENT
EFLG:	DS	1	;END OF PROGRAM FLAG (TO ALLOW PRINTING OF END STMT)
OPCODE:	DS	2	;CURRENT OPCODE FROM SYMBOL TABLE
SAVVAL:	DS	2	;SAVED CONTENTS OF VAL
LFLAG:	DS	1	;LISTING FLAG:'A-D' = PRN FILE DESTN DRIVE
			;'Z' = NO LISTING; 'X' = LISTING TO SCREEN
			;'Y' = LISTING TO SCREEN, ERRORS ECHOED TO PRINTER
			;'P' = LISTING TO PRINTER
HFLAG:	DS	1	;HEX OBJ FLAG 'Z' = NO HEX OBJ, 'A - D') = HEX OBJ DESTN DRIVE
ERRFLG:	DS	1	;ERROR CHARACTER FOR THIS LINE
ERCNT:	DS	1	;NO OF ERRORS COUNT (BCD FORMAT)
TEMP:	DS	2	;TEMP 2 BYTE AREA
MULT:	DS	2	;BASE OF NUMBER IN INT CONVERT LOOP
SYMPTR:	DS	2	;ADDRESS OF NEXT SYMBOL TABLE ENTRY
SYMPT:	DS	2	;ADDRESS OF BEGINNING OF SYMBOL TABLE
PCFLAG:	DS	1	;PC RELATIVE VALUE IN EVAL
UFLAG:	DS	1	;UNDEFINED FLAG FROM EVAL, 0 = ALL OK, 1 OR >1 = UNDEFINED
EVFLGS:	DS	1	;FLAG FIELD FROM LAST SYMLUK
IXFLAG:	DS	1	;INDEX DISPLACEMENT BEING CALCULATED
;
;
;	EXPRESSION EVALUATOR
;
;	VALID OPERATORS ARE: +, -, * AND /
;
;	VALID ELEMENTS ARE: ID'S, NUMBERS, AND '$' FOR PC
;
EVAL	EQU	$
	MVI A,0
	STA OP
	STA UFLAG 	;DEFAULT OP TO +, UFLAG=0
	STA PCFLAG	;RESET PC RELATIVE FLAG
	STA EVFLGS	;RESET FLAGS FROM LAST SEARCH
	LXI H,0
	SHLD VAL 	;SET VAL TO 0000
EVAL1	EQU	$
	CALL GNC	;GET NEXT ELEMENT OR OPERATOR
	CPI '0'
	JC EVAL3
	CPI '9'+1
	JC EVAL9 	;BRANCH IF NUMBER
EVAL3	EQU	$
	CPI '$'
	JZ EVAL11 	;BRANCH IF PC REF
	CPI 'A'
	JC EVAL5
	CPI 'Z'+1
	JC EVAL13 	;BRANCH IF ID
EVAL5	EQU	$
	CPI '('
	JZ EVAL28D	;BRACKETS ILLEGAL
	CPI '+'
	JZ EVAL22
	CPI '-'
	JZ EVAL24
	CPI '*'
	JZ EVAL25
	CPI '/'
	JZ EVAL26
	CPI 27H
	JZ EVAL29	;PROCESS SINGLE BYTE QUOTED STRING
	RET		;GET OUT OF HERE WE ARE DONE
;
;	PROCESS NUMBER
;
EVAL9	EQU	$
	CALL BACKUP
	CALL INT
	JMP EVAL28
;
;	PROCESS '$' REF
;
EVAL11	EQU	$
	LHLD PC
	SHLD INTBUF
	LDA PCFLAG	;FETCH PC RELATIVE VALUE FLAG
	INR A
	STA PCFLAG	;SET FLAG
	JMP EVAL28
;
;	PROCESS ID
;
EVAL13	EQU	$
	CALL BACKUP
	CALL ID
	CALL BACKUP 	;BACKUP SO AS TO NOT IGNORE OPERATOR OR COMMA
	LXI H,IDBUF
	CALL SYMLUK
	JNZ EVAL19 	;BRANCH IF UNDEFINED
	LDA PCFLAG	;FETCH PC RELATIVE FLAG
	INR A		;
	STA PCFLAG	;SET FLAG TO MARK AS PC-RELATIVE
	MOV A,M
	STA INTBUF
	INX H
	MOV A,M
	STA INTBUF+1
	JMP EVAL28
;
EVAL19	EQU	$	;PROCESS UNDEFINED ID
	LXI H,0
	SHLD INTBUF 	;SET VALUE TO 0000
	LDA UFLAG
	ORI 1
	STA UFLAG 	;SET UNDEFINED FLAG
	JMP EVAL28
;
;	PROCESS OPERATORS
;
EVAL22	EQU	$
	MVI A,1
	JMP EVAL27 
;
EVAL24	EQU	$
	MVI A,2
	JMP EVAL27
;
EVAL25	EQU	$
	MVI A,3
	JMP EVAL27
;
EVAL26	EQU	$
	MVI A,4
;
EVAL27	EQU	$
	STA OP
	JMP EVAL1
;
;	PROCESS VALUE USING CURRENT OPERATOR
;
EVAL28	EQU	$	;VAL = VAL OP INTBUF
	LDA EVFLGS	;FETCH LABEL TYPE
	ANI 20H		;MASK SGL REGISTER
	LDA OP
	JNZ EVAL28E	;CHECK IF OPERATOR
	ORA A		;ANY OPERATOR ?
	JZ EVAL28C	;O.K TO PROCESS
	DCR A
	JZ EVAL28C	;BRANCH IF +
	DCR A
	JZ EVAL28A	;BRANCH IF SUBTRACT
	DCR A
	JZ EVAL28B	;BRANCH IF MULTIPLY
	DCR A
	JZ EVAL28F	;BRANCH IF DIVIDE
EVAL28D:MVI A,'E'
	STA ERRFLG	;FLAG EXPRESSION ERROR
	JMP EVAL1	;EXIT THIS LINE
;
EVAL28A EQU	$	;SUBTRACT
	LHLD VAL
	XCHG
	LHLD INTBUF
	MOV A,E
	SUB L
	MOV L,A
	MOV A,D
	SBB H
	MOV H,A
	SHLD VAL
	JMP EVAL1
;
EVAL28B	EQU	$	;MULTIPLY
	LHLD VAL
	XCHG
	LHLD INTBUF
	CALL MUL16
	SHLD VAL
	JMP EVAL1
;
EVAL28C:LHLD VAL	;+
	XCHG
	LHLD INTBUF
	DAD D
	SHLD VAL 
	LDA IXFLAG
	ORA A
	JZ EVAL1	;NOT INDEX, SO O.K
	MOV A,H		;FETCH VAL MS BIT
	ORA A		;SHOULD BE BLANK FOR INDEX
	JNZ EVAL28G	;ERROR
	MOV A,L		;FETCH LS BIT
	ANI 80H
	JZ EVAL1	;O.K
EVAL28G:MVI A,'V'
	STA ERRFLG
	JMP EVAL1
;
EVAL28E:ORA A		;ANY OPERATOR ?
	JZ EVAL28C	;O.K TO PROCESS
	JMP EVAL28D	;ELSE ERROR
;
EVAL28F	EQU	$	;DIVIDE
	LHLD INTBUF
	XCHG
	LHLD VAL
	CALL DIVIDE
	SHLD VAL
	JC EVAL28D	;DIVIDE BY 0 ERROR
	JMP EVAL1
;
;	PROCESS SINGLE BYTE IN QUOTES
;
EVAL29	EQU	$
	LHLD PTR1
	MOV A,M 	;GET CHARACTER
	INX H
	CPI 27H
	JNZ EVAL29A	;NOT DOUBLE QUOTES
	MOV A,M		;FETCH NEXT CHAR
	INX H
EVAL29A:STA INTBUF
	MOV A,M		;NEXT CHAR
	SUI 27H		;1 OR 2 BYTES?
	JZ EVAL29B	;ONLY 1
	MOV A,M		;FETCH SECOND BYTE
	INX H		;PTR TO TRAILING QUOTES
EVAL29B:SHLD PTR1
	STA INTBUF+1 	;MAKE 2 BYTE VALUE
	CALL GNC 	;BYPASS TRAILING QUOTE
	JMP EVAL28	;AND GO PROCESS VALUE NORMALLY
;
OP:	DS	1	;CURRENT OPERATOR FOR EVAL
;
;	ID - COLLECT ID AND PLACE IN IDBUF
;
ID	EQU	$
	PUSH H
	PUSH D
	PUSH B 		;SAVE REGS
	MVI A,' '
	LXI H,IDBUF+1
	LXI D,IDBUF
	LXI B,15
	STAX D
	CALL MOVE 	;BLANK IDBUF
	LXI H,IDBUF
	CALL GNC
	CPI 'A'
	JC ID5
	CPI 'Z'+1
	JNC ID5 	;IF NOT A LETTER THEN BRANCH
	JMP ID3
;
ID2	EQU	$
	CALL CASCVRT	;CONVERT L/C TO U/C
	CPI 'A'
	JC ID1
	CPI 'Z'+1
	JNC ID1 	;IF NOT A LETTER THEN BRANCH
ID3:	MOV M,A
	INX H
	PUSH H
	LHLD PTR1
	MOV A,M
	INX H
	SHLD PTR1
	POP H
	JMP ID2
;
ID1:	CPI '.'
	JZ ID3 		; ALLLOW LABELS WITH '.' IN THEM (E.G.  LAB.01)
	CPI '$'
	JZ ID3 		; ALLOW $ FILLERS (E.G.  SQR$ROOT)
	CPI '0'
	JC ID4
	CPI '9'+1
	JC ID3 		;ALLOW DIGITS
ID4:	POP B
	POP D
	POP H
	RET
;
ID5:	MVI A,'L'
	STA ERRFLG
	JMP ID4
;
;	INT - CONVERT CHARACTERS TO BINARY
;
;	ALLOW TRAILING 'H' FOR HEX, 'O' OR 'Q' FOR OCTAL
;	AND 'B' FOR BINARY
;	DEFAULT TYPE IS DECIMAL (BASE 10)
;
INT	EQU	$
	LHLD PTR1
	SHLD TEMP  	;SAVE POINTER
	LXI H,10
	SHLD MULT 	;SET DEFAULT BASE TO 10
	MVI B,0		;SET UP LENGTH COUNTER
	CALL GNC	;SKIP BLANKS
INT1	EQU	$
	CPI '+'
	JZ INT1A 	;BRANCH IF A TERMINATOR
	CPI '-'
	JZ INT1A
	CPI '*'
	JZ INT1A
	CPI '/'
	JZ INT1A
	CPI 0DH
	JZ INT1A	
	CPI ';'
	JZ INT1A
	CPI '('
	JZ INT1A
	CPI ')'
	JZ INT1A
	CPI ','
	JZ INT1A
	CPI 20H
	JZ INT1A
	LHLD PTR1
	MOV A,M
	INX H
	SHLD PTR1 	;GET NEXT CHARACTER
	INR B
	JMP INT1 	;INCREMENT COUNTER AND CONTINUE LOOP
;
INT1A	EQU	$
	DCX H
	SHLD PTR1
	DCX H
	MOV A,M
	CALL CASCVRT
	CPI 'H'
	JNZ INT2A 	;BRANCH IF NOT HEX
	DCR B		;DECREMENT COUNTER
	LXI H,16
	SHLD MULT 	;SET UP BASE 16
	JMP INT4
;
INT2A:	CPI 'Q'
	JZ INT3		;BRANCH IF OCTAL
	CPI 'O'
	JZ INT3		;BRANCH IF OCTAL
	CPI 'B'
	JNZ INT4 	;BRANCH IF NOT BINARY
	DCR B		;DECREMENT COUNTER
	LXI H,2
	SHLD MULT  	;SET UP BASE 2
	JMP INT4
;
INT3:	DCR B		;DECR COUNTER
	LXI H,8		;SET UP BASE 8
	SHLD MULT
INT4:	LHLD PTR1
	XCHG
	LHLD TEMP
	SHLD PTR1
	XCHG
	SHLD TEMP 	;SAVE PTR 
	LXI D,0 	;SET UP ACCUMULATOR
	CALL GNC
	CALL BACKUP
INT5	EQU	$
	LHLD PTR1
	MOV A,M
	INX H
	SHLD PTR1
	CALL CASCVRT
	CPI 'A'
	JC $+5
	ADI 9 		;FOR A-F
	ANI 0FH
	PUSH PSW 	;GET BINARY VALUE OF THIS DIGIT
	PUSH B		;SAVE COUNTER
	LHLD MULT
	CALL MUL16
	POP B		;RESTORE COUNTER
	POP PSW
	MOV E,A
	MVI D,0
	DAD D 		;ADD IN NEW DIGIT
	XCHG
	DCR B
	JNZ INT5	;GO BACK IF MORE TO DO
INT6:	LHLD TEMP
	SHLD PTR1
	XCHG
	SHLD INTBUF 	;SAVE VALUE
	RET
;
;	SETUP - SET UP FILES FOR Z80ASM
;		COMMAND SYNTAX AS FOR 'ASM'
;
;	INPUT FROM CONSOLE IS FILENAME.ABC
;
;	A= SOURCE (.ZSM) FILE DRIVE NAME
;	B= (.HEX) FILE DESTINATION DRIVE NAME OR Z
;	C= (.PRN) FILE DESTINATION DRIVE NAME
;	    OR P, X, Y, OR Z FOR LISTING
;
SETUP	EQU	$
	LXI H,FCB1
	LXI D,5CH
	LXI B,33
	CALL MOVE 	;GET DEFAULT FCB
	LXI H,FCB1+9
	LXI D,ASMEXT
	LXI B,3
	CALL MOVE 	;SET UP EXTENSION
	LXI H,FCB2
	LXI D,5CH
	LXI B,33
	CALL MOVE 	;GET DEFAULT FCB
	LXI H,FCB2+9
	LXI D,HEXEXT
	LXI B,3
	CALL MOVE 	;SET UP EXTENSION
	LXI H,FCB3
	LXI D,5CH
	LXI B,33
	CALL MOVE	;GET DEFAULT FCB
	LXI H,FCB3+9
	LXI D,PRNEXT
	LXI B,3
	CALL MOVE	;SET UP EXTENSION
	LDA 5CH+9
	CPI ' '		;TEST FOR DEFAULT DRIVE
	JZ SETUPA
	SUI 40H		;MAKE DRIVE CODE
	CPI 5H		;TEST VALID
	JC SETUPB	;OK
SETUPA:	LDA 5CH		;FETCH DEFAULT
SETUPB:	LXI D,FCB1	;SET SOURCE DRIVE
	STAX D
	CALL OPNFIL
	JZ SETER1 	;BRANCH IF SOURCE FILE NOT FOUND
	LXI H,5CH+9	;FILE EXTENSION
	MOV A,M		;TEST FOR SOURCE/DEFAULT
	CPI 20H
	JNZ SETUPC	;DRIVE SPECIFIED
	LDA 5CH		;SET UP DEFAULT
	MOV M,A
	INX H
	MOV M,A		;SET DEFAULT HEX DESTN
SETUPC:	LDA 5CH+11	;FETCH LIST FLAG
	CPI ' '		;DEFAULT ?
	JNZ SETUPL
	LDA 5CH		;FETCH DEFAULT
SETUPL:	STA LFLAG 	;SET UP LISTING FLAG
	CPI 45H		;LISTING TO FILE OR OUTPUT ?
	JNC SETUPH	;TRY HEX OUTPUT
	SUI 40H		;MAKE DRIVE CODE
	CPI 5H		;VALID ?
	JC SETUPP	;OTHERWISE DEFAULT DESTN
	LDA 5CH		;FETCH DEFAULT
SETUPP:	LXI D,FCB3
	STAX D
	CALL DELFIL
	LXI D,FCB3
	CALL CREFIL
	JZ SETER3	;BRANCH IF UNABLE TO CREATE
	LXI D,FCB3
	CALL OPNFIL
	JZ SETER3	;BRANCH IF UNABLE TO OPEN
SETUPH:	LDA 5CH+10
	STA HFLAG 	;SET UP HEX FLAG
	CPI 'Z'		;TEST FOR SKIP HEX
	JZ SETUP1 	;BRANCH IF NO HEX FILE SETUP
	SUI 40H		;MAKE DRIVE CODE
	CPI 5H		;VALID  ?
	JC SETUPD	;OTHERWISE DEFAULT DESTN
	LDA 5CH		;FETCH DEFAULT
SETUPD:	LXI D,FCB2
	STAX D
	CALL DELFIL 	;DELETE FILE
	LXI D,FCB2
	CALL CREFIL
	JZ SETER2 	;BRANCH IF UNABLE TO CREATE
	LXI D,FCB2
	CALL OPNFIL
	JZ SETER2 	;BRANCH IF UNABLE TO OPEN
SETUP1	EQU	$
	LXI H,INBUF+1024
	SHLD IBP
	XRA A
	STA OBP2 	;SET UP POINTERS
	RET 		;AND GET OUT OF HERE
;
SETER1:	LXI D,SM1
	JMP SETERR	;MSG AND REBOOT
;
SETER2:	LXI D,SM2
	JMP SETERR 	;MSG AND REBOOT
;
SETER3:	LXI D,SM3
SETERR:	CALL WMSG
	JMP 0 		;REBOOT
;
SM1:	DB	13,10,'SOURCE (.ZSM) FILE NOT FOUND',13,10,'$'
;
SM2:	DB	13,10,'UNABLE TO CREATE/OPEN OBJECT (.HEX) FILE',13,10,'$'
;
SM3:	DB	13,10,'UNABLE TO CREATE/OPEN OUTPUT (.PRN) FILE',13,10,'$'
;
ASMEXT:	DB	'ZSM'
HEXEXT:	DB	'HEX'
PRNEXT:	DB	'PRN'
;
;	SYMENT - ENTER A SYMBOL INTO THE SYMBOL TABLE
;	UPON ENTRY HL POINTS TO NEW ENTRY
;
;	ENTRY FORMAT:	FLAGS/LENGTH (EACH 4 BITS)
;			N A M E ...  (UP TO 11 BYTES)
;			VALUE LOW    (1 BYTE)
;			VALUE HIGH   (1 BYTE)
;			TYPE BYTE    (1 BYTE)
;
;	ON RETURN HL POINTS TO VALUE LOW BYTE IN NEW ENTRY FOR POSSIBLE
;	FURTHER UPDATE (USED BY EQU PSEUDO OPERATOR)
;
SYMENT	EQU	$
	MOV A,M
	PUSH B
	XCHG
	ANI 0FH
	MOV C,A
	MVI B,0 	;GET LEN
	LHLD SYMPTR
	CALL MOVE 	;MOVE INTO SYMBOL TABLE
	SHLD SYMPTR
	MVI M,0 	; SET UP NEW POINTER AND NEW END MARKER
	DCX H
	DCX H
	DCX H 		;BACKUP TO POINT TO VALUE LOW FIELD
	POP B
	RET
;
;	SYMLUK - LOOK UP SYMBOLS IN TABLE
;
;	ON RETURN Z=0 MEANS SYMBOL NOT FOUND.
;		  Z=1 SYMBOL FOUND, HL POINTS TO VALUE LOW BYTE IN TABLE ENTRY
;
SYMLUK	EQU	$
	XCHG
	LHLD SYMPT 	;GET POINTER TO BEGINING OF TABLE
	XCHG
SYML1:	LDAX D
	CPI 0
	JZ SYMNF 	;BRANCH IF END OF TABLE
	STA EVFLGS 	;SAVE FOR MAIN PROCESSOR
	ANI 0FH
	SUI 4
	MOV B,A
	INX D 		;SET UP FOR COMPARE
	CALL CMPCHR
	JZ SYML2 	;BRANCH IF MATCH
	DCX D		;BACK UP LENGTH BYTE AGAIN
SYML3	EQU	$
	LDAX D
	ANI 0FH
	MOV C,A
	MVI B,0
	XCHG
	DAD B
	XCHG
	JMP SYML1 	;ADVANCE POINTER AND CONTINUE TO LOOP
;
SYML2	EQU	$	;NOW SEE IF EXACT MATCH
	DCX D
	LDAX D
	ANI 0FH
	SUI 4  		;GET LENGTH
	PUSH H
	MOV C,A
	MVI B,0
	DAD B
	MOV A,M
	CPI ' '
	POP H
	JNZ SYML3 	;IF NXT CHR NOT BLANK THEN NOT EXACT MATCH
	LDAX D
	ANI 0FH
	DCR A
	DCR A
	DCR A
	MOV C,A
	MVI B,0
	XCHG
	DAD B
	XRA A
	RET 		;POINT TO VALUE LOW AND EXIT
;
SYMNF:	XRA A
	INR A
	RET 		;SET Z=0 AND RETURN
;
;	GNR - GET NEXT RECORD - FILL REC UNTIL 0AH OR 1AH (CTRL/Z) IS FOUND
;	TRUNCATE SOURCE LINE IF > 128 CHARACTERS
;
GNR:	LXI H,REC
	SHLD PTR1 	;RESET POINTER
	MVI M,' '
	XCHG
	LXI H,REC+1
	LXI B,7FH
	CALL MOVE 	;BLANK BUFFER
	LXI H,REC	;GET ADDRESS OF RECORD BACK AGAIN
	MVI C,7FH	;LOAD BUFFER COUNT
GNR1:	CALL GNB
	CPI 1AH
	RZ 		;RETURN IF EOF MARKER (CTRL/Z) IF FOUND
	CPI 09H
	JZ GNR2		;BRANCH IF TAB CHARACTER
	MOV M,A
	INX H
	DCR C		;DECR BUFFER COUNT
	JZ GNR3		;FULL, TRUNCATE LINE
	CPI 0AH
	JNZ GNR1 	;BRANCH IF NOT LF
	RET
;
GNR2	EQU	$	;PROCESS TAB
	MOV A,C		;FETCH BUFFER COUNT
	SUI 8H		;ADJUST FOR TAB
	MOV C,A		;REPLACE COUNT
	JM GNR3		;BUFFER FULL, EXIT
	LXI D,8
	DAD D
	MOV A,L
	ANI 0F8H
	MOV L,A 	;PROCESS TAB STOP
	JMP GNR1
;
GNR3:	MVI M,0DH
	INX H
	MVI M,0AH	;TERMINATE BUFFER
	RET
;
;	GNC - GET NEXT CHARACTER 
;	USE PTR1 TO INDEX INTO REC, SKIP BLANKS
;
GNC	EQU	$
	PUSH H
	LHLD PTR1
	MOV A,M
	CPI ' '
	INX H
	JZ $-4 		;SKIP BLANKS
	CPI 09H
	JZ $-9 		;BRANCH IF TAB CHARACTER
	CALL CASCVRT	;CONVERT L/C TO U/C
	SHLD PTR1
	POP H
	RET
;
;	BACKUP - BACKUP PTR1 AND RETURN CHARACTER
;
BACKUP:	PUSH H
	PUSH PSW
	LHLD PTR1
	DCX H
	MOV A,M
	SHLD PTR1
	CALL CASCVRT
	MOV C,A
	POP PSW
	MOV A,C
	POP H
	RET
;						;
;-----------------------------------------------;
;						;
;	MAIN ASSEMBLER MODULE			;
;						;
;-----------------------------------------------;
;
;	LOCAL DATA AREA FOR ASSEMBLER
;
;
SYMAREA:DS	15	;AREA FOR SYMBOL TABLE BUILD
SYMADR:	DS	2	;ADDRESS OF VALUE LOW FIELD FOR LAST SYMENT
OLDADR:	DW	-1	;LAST ADDR OF WOBJ
OBJADR:	DS	2
PAGENO:	DS	1
;
;
MAXLNE	EQU	56	;LINES PER PAGE
;
;
Z80ASM	EQU $
;
;	INIT FIELDS AND SET UP FILES
;
	LXI SP,STACK+128
	JMP STACK+128
VSNMSG:	DB	13,10,10,'ZILOG/MOSTEK Z-80 ASSEMBLER   VERSION 2.4  (1982)',13,10,'$'
STACK:	DS	128
	LXI D,VSNMSG
	CALL WMSG	;DISPLAY ON CONSOLE
	LXI H,SYM	;GET ADDRESS OF SYMBOL TABLE
	SHLD SYMPT
	LHLD SYMBEG
	SHLD SYMPTR 	;SET UP POINTERS
	CALL SETUP	;PROCESS FILE NAME, PARAMETERS, ETC.
	MVI A,MAXLNE+1
	STA CURLNE 	;SET UP FOR HEAD OF FORM ON FIRST PRINT
	XRA A
	STA PASSNO 	;INDICATE PASS 1
	STA ERCNT	;CLEAR ERROR COUNT
	LXI H,0
	SHLD PC 	;SET UP DEFAULT PROGRAM ORIGIN
;
;	MAIN LOOP - READ A SOURCE RECORD
;		    PROCESS LABEL AND OPCODE
;		    PRINT LINE (UNLESS OPTION=N)
;		    OUTPUT HEX (IF NECESSARY)
;		    BACK TO MAIN LOOP FOR NEXT RECORD
;
NEXT	EQU	$
	XRA A
	STA LEN
	STA EFLG
	STA EQUFLG
	STA IXFLAG
	LXI H,0
	SHLD LEN2 	;INIT LENGTH & FLGS
	MVI A,' '
	STA ERRFLG 	;FOR THIS RECORD
	CALL GNR 	;GET NEXT RECORD
	CPI 1AH
	JZ S321		;BRANCH IF EOF
	LDA REC 	;GET COL 1
	CPI 09H
	JZ S12		;BRANCH IF TAB
	CPI 0DH
	JZ S8		;IGNORE NULL LINE
	CPI ' '
	JZ S12		;BRANCH IF NO LABEL
	CPI ';'
	JZ S8		;IF COMMENT THEN IGNORE
	CALL ID
	LDA ERRFLG	;ANY ERROR
	CPI ' '
	JNZ ENDSTMT	;EXIT
;
;	CALCULATE LENGTH OF SYMBOL AND BUILD ENTRY
;
S9	EQU	$
	MVI B,0 	;LENGTH + FLAGS
	LXI H,IDBUF
	LXI D,SYMAREA+1
S10	EQU	$
	MOV A,M
	CPI ' '
	JZ S10A
	STAX D
	INX H
	INX D
	INR B
	JMP S10
;
S8:	CALL GNC	;STEP OVER SEPARATOR
	JMP ENDSTMT
;
S10A	EQU	$	;SYMBOL COLLECTED
	MOV A,B
	CPI 0CH
	JC S10B 	;BRANCH IF LEN < 12 (I.E. OK)
	MVI A,'L'
	STA ERRFLG
	JMP ENDSTMT 	;ELSE LABEL ERROR
;
S10B	EQU	$
	ADI 44H		;ADD 4 FOR OVERHEAD
	STA SYMAREA 	;MARK LABEL FLAG 40H
	XCHG		;SWITCH REGISTERS
	LDA PC
	MOV M,A
	INX H 		;MOVE IN PC AS VALUE
	LDA PC+1
	MOV M,A
	INX H
	MVI M,0 	;AND SET TYPE =0
	LHLD SYMCND
	SHLD SYMPT	;NO CONFLICT WITH REG NAMES
	LXI H,IDBUF
	CALL SYMLUK
	PUSH H		;SAVE TABLE PTR
	LXI H,SYM
	SHLD SYMPT	;PUT IT BACK THE WAY IT WAS
	POP H		;RESTORE SYMBOL TABLE PTR
	JNZ S11 	;BRANCH IF NOT ALREADY THERE
	PUSH H		;SAVE TABLE PTR
S10C:	DCX H		;BACK UP PTR
	MOV A,M		;FETCH LABEL CHAR
	ORA A		;TERMINATOR ?
	JNZ S10C	;MORE IN LABEL
	INX H		;INCR PTR TO IDENTITY
	MOV A,M		;FETCH IDENTITY CHAR
	ANI 10H		;EQUATE LABEL
	POP H		;RECOVER TABLE PTR
	JNZ S12		;DONT MARK AS ERROR
	MOV E,M		;FETCH ADDR LSB
	INX H		;INCR PTR
	MOV D,M		;FETCH LABEL ADDR MSB
	LHLD PC		;FETCH CURRENT ADDR
	CALL CMPHD	;SAME ?
	JZ S12		;VALUE OK
	MVI A,'M'
	STA ERRFLG
	JMP ENDSTMT 	;ELSE MULTI DEFINED ERROR
;
S11	EQU	$
	LXI H,SYMAREA
	CALL SYMENT	;ENTER SYMBOL INTO TABLE
	SHLD SYMADR	;SAVE ADDRESS FOR EQU
;
;	NOW PROCESS OPCODE
;
S12	EQU	$
	CALL GNC	;FETCH CHAR AFTER TAB OR SPACE
	CPI 9H
	JZ S12		;STEP OVER TABS
	CPI 0DH
	JZ ENDSTMT
	CPI 0AH
	JZ ENDSTMT	;IGNORE BLANK LINE
	CPI ';'
	JZ ENDSTMT	;IGNORE COMMENT
	CALL BACKUP	;RESTORE PTRS
	CALL ID
	CPI ' '		;TEST OP-CODE SEPARATOR
	JZ S12C
	CPI 09H
	JZ S12C
	CPI 0AH
	JZ S12C
	CPI 0DH
	JZ S12C
	JMP S12B
;
S12C:	LDA IDBUF
	CPI ' '
	JZ S12B		;ERROR EXIT
S12A:	LXI H,IDBUF
	CALL SYMLUK
	JZ S16 		;BRANCH IF FOUND
S12B:	MVI A,'O'
	STA ERRFLG
	JMP ENDSTMT 	;ERROR IF UNDEFINED OPCODE
;
S16	EQU	$
	LDA EVFLGS	;FETCH LABEL FLAG
	ANI 0F0H	;TEST IF OP-CODE
	JNZ S12B	;ERROR, NOT OP-CODE
	MOV A,M
	STA OPCODE
	INX H
	MOV A,M
	STA OPCODE+1 	;SAVE OPCODE
	INX H
	MOV A,M 	;GET TYPE BYTE
	DCR A
	ADD A 		;-1 AND DOUBLE FOR TABLE INDEX
	MOV E,A
	MVI D,0
	LXI H,TYPTBL
	DAD D
	MOV E,M
	INX H
	MOV D,M
	XCHG
	PCHL		;DISPATCH TO PROPER INSTRUCTION TYPE
;
;-----------------------------------------------;
;						;
;	INSTRUCTION CLASS DISPATCH TABLE	;
;						;
;-----------------------------------------------;
;
TYPTBL	EQU	$
	DW	S18	;CLASS 1 - OPCODE ONLY
	DW	S24	;CLASS 2 - ROTATES
	DW	S42	;CLASS 3 - JUMPS (NON RELATIVE) CALLS
	DW	S62	;CLASS 4 - RELATIVE JUMPS (JR AND DJNZ)
	DW	S73	;CLASS 5 - RST
	DW	S77	;CLASS 6 - ARITHMETIC INSTRUCTIONS
	DW	S97	;CLASS 7 - I/O
	DW	S116	;CLASS 8 - LD INSTRUCTIONS
	DW	S220	;CLASS 9 - PUSH,POP
	DW	S228	;CLASS 10- EXCHANGE (EX)
	DW	S243	;CLASS 11- RETURNS
	DW	S250	;CLASS 12- BIT,SET,RES
	DW	S268	;CLASS 13- INC,DEC
	DW	S301	;CLASS 14- PSEUDO OPERATORS
;
;	CLASS 1 - OPCODE ONLY
;
S18	EQU	$
	MVI A,1
	STA LEN
	LDA OPCODE
	STA INST
	LDA OPCODE+1
	CPI 0FFH	;IM SET?
	JZ S19
	ORA A
	JZ ENDSTMT 	;BRANCH IF ONLY 1 BYTE 
S18A:	MVI A,2
	STA LEN
	LDA OPCODE+1
	STA INST+1
	JMP ENDSTMT
;
S19:	CALL GNC
	CPI '2'
	MVI B,5EH
	JZ S19A
	MVI B,56H
	CPI '1'
	JZ S19A
	MVI B,46H
	CPI '0'
	JNZ S24A
S19A:	MOV A,B
	STA OPCODE+1
	CALL GNC		;BY-PASS NUMBER
	JMP S18A
;
;	CLASS 2 - ROTATES
;
S24	EQU	$
	CALL GNC
	CPI '('
	JZ S30 		;BRANCH IF () FORM
	CALL BACKUP
	CALL ID
	LXI H,IDBUF
	CALL SYMLUK
	JZ S27
S24A:	MVI A,'O'
	STA ERRFLG
	JMP ENDSTMT 	;BRANCH IF UNDEFINED OPERAND
;
S27	EQU	$
	LDA IDBUF
	MVI A,0CBH
	STA INST
	LDA OPCODE
	MOV B,A
	MOV A,M
	ORA B
	STA INST+1
	MVI A,2
	STA LEN
	JMP ENDSTMT
;
S30	EQU	$
	CALL GNC
	CALL GNC
	CPI 'L'
	CZ S131		;CHECK ONLY HL
	JZ S40 		;BRANCH IF (HL)
	CPI 'Y'
	STA IXFLAG	;MARK AS INDEX
	CZ S131		;CHECK ONLY IY+
	JZ S38 		;BRANCH IF (IY)
	CALL S131	;CHECK ONLY IX+
	JNZ S24A	;ERROR
	MVI A,0DDH	;PROCESS AS (IX)
	STA INST
S33	EQU	$
	MVI A,0CBH
	STA INST+1
	LDA OPCODE
	ADI 6
	STA INST+3
	CALL GNC 	;BYPASS +
	CALL EVAL
	CALL GNC	;BYPASS )
	LDA VAL
	STA INST+2
	MVI A,4
	STA LEN
	JMP ENDSTMT
;
S38	EQU	$
	MVI A,0FDH
	STA INST
	JMP S33		;DO IX AND IY SIMILARLY
;
S40	EQU	$
	CALL GNC
	CALL GNC	;BYPASS )
	MVI A,0CBH
	STA INST
	LDA OPCODE
	ADI 6
	STA INST+1
	MVI A,2
	STA LEN
	JMP ENDSTMT 
;
;	CLASS 3 - JUMPS - CALLS
;
S42	EQU	$
	CALL	GNC
	CPI '('
	JZ S53 		;BRANCH IF () FORM
	LHLD PTR1
	MOV A,M
	CPI ','
	JZ S49 		;BRANCH IF CONDITIONAL TYPE
	INX H
	MOV A,M
	CPI ','
	JZ S49
	LDA OPCODE
	STA INST
	MVI A,3
	STA LEN
	CALL BACKUP
S46	EQU	$
	CALL EVAL
	LHLD VAL
	SHLD INST+1
	JMP ENDSTMT
;
S49	EQU	$	;PROCESS CONDITIONAL JUMPS, CALLS
	LDA OPCODE
	ANI 0C6H
	STA INST
	MVI A,3
	STA LEN
	LHLD SYMCND
	SHLD SYMPT 	;SO NO CONFLICTS WITH REGISTER NAMES
	CALL BACKUP
	CALL EVAL
	LXI H,SYM
	SHLD SYMPT 	;PUT IT BACK THE WAY IT WAS
	LDA UFLAG	;VALID LABEL ?
	ORA A
	JNZ S24A	;EARLY ERROR EXIT
	LDA VAL
	RLC
	RLC
	RLC
	ANI 38H
	MOV B,A
	LDA INST
	ORA B
	STA INST
	MVI A,3
	STA LEN
	JMP S46 	;NOW GO PROCESS LIKE NON CONDITIONAL
;
S53	EQU	$	;PROCESS () FORM
	CALL GNC
	CALL GNC 	;GET REGISTER TYPE
	CPI 'L'
	CZ S61		;CHECK ONLY HL
	JZ S58 		;BRANCH IF (HL)
	CPI 'Y'
	CZ S61		;CHECK ONLY IY
	JZ S60
	CALL S61	;CHECK ONLY IX
	JNZ S24A	;ERROR EXIT
	MVI A,0DDH	;PROCESS AS (IX)
	STA INST
S56	EQU	$
	MVI A,0E9H
	STA INST+1
	MVI A,2
	STA LEN
	CALL GNC
	CALL GNC	;BYPASS )
	JMP ENDSTMT
;
S58	EQU	$
	MVI A,0E9H
	STA INST
	MVI A,1
	STA LEN
	CALL GNC
	CALL GNC	;BYPASS )
	JMP ENDSTMT
;
S60	EQU	$
	MVI A,0FDH
	STA INST
	JMP S56
;
S61:	CALL GNC
	CPI ')'		;TERMINATOR ?
	CALL BACKUP	;PREV CHAR
	RET		;
;
;	CLASS 4 - RELATIVE JUMPS (JR AND DJNZ)
;
S62	EQU	$
	CALL GNC
	LHLD PTR1
	MOV A,M
	CPI ','
	JZ S68
	INX H
	MOV A,M
	CPI ','
	JZ S68 		;BRANCH IF CONDITIONAL
	LDA OPCODE
	STA INST
	MVI A,2
	STA LEN
	CALL BACKUP
	JMP S68A
;
S68:	EQU  $
	LHLD SYMCND
	SHLD SYMPT 	;SO NOT CONFLICT WITH REG NAMES
	CALL BACKUP
	CALL EVAL
	LXI H,SYM
	SHLD SYMPT 	;PUT IT BACK THE WAY IT WAS
	LDA UFLAG	;VALID LABEL ?
	ORA A
	JNZ S24A	;EARLY ERROR EXIT
	LDA VAL
	RLC
	RLC
	RLC
	ANI 38H
	ADI 20H
	STA INST
	MVI A,2
	STA LEN
S68A:	CALL EVAL
	LHLD VAL
	XCHG
	LXI H,0H	;CLEAR
	LDA PCFLAG	;FETCH PC RELATIVE FLAG
	ORA A		;PC RELATIVE VALUE ?
	JZ S68A1	;SKIP PC RELATIVE
	LHLD PC
S68A1:	MOV A,L
	SUB E
	CMA
	MOV L,A
	MOV A,H
	SBB D
	CMA
	MOV H,A
	DCX H
	MOV A,H
	ORA A
	JZ POSTST
	INR A
	JNZ S68C
NEGTST:	MOV A,L
	ORA A
	JP S68C
	JMP S68B
;
POSTST:	MOV A,L
	ORA A
	JM S68C
S68B:	MOV H,L
	LDA INST	;ADD OPCODE TO DISPLACEMENT
	MOV L,A
S68B1:	SHLD INST
	JMP ENDSTMT
;
S68C:	MVI A,'V'
	STA ERRFLG
	LXI H,0H
	JMP S68B1
;
;	CLASS 5 - RESTARTS
;
S73	EQU	$
	CALL EVAL
	LDA VAL		;FETCH OP-CODE VALUE
	ANI 0C7H	;MASK RST BITS OUT
	JNZ S24A	;OUT OF VALUE ERROR
	LDA VAL		;FETCH OP-CODE VALUE
	ANI 38H		;MASK TO RST BITS
	ORI 0C7H	;MAKE RST CODE
	STA INST 
	MVI A,1
	STA LEN
	JMP ENDSTMT
;
;	CLASS 6 - ARITHMETIC OPCODES
;
;	ADD,SUB,ADC,SBC,AND,OR,XOR,CP
;
S77	EQU	$
	CALL GNC
	LHLD PTR1	;FETCH TEXT PTR
	CPI 27H		;TEST IF SINGLE CHAR
	JZ S77B		;PROCESS NORMALLY
	MOV A,M		;FETCH 2ND CHAR
	CPI ','		;INDICATES FORMAT ADD A,r
	INX H		;STEP PTR TO SOURCE REG
	SHLD PTR1
	JZ S77C		;GO AND PROCESS
	CALL BACKUP	;ELSE RESTORE PTRS FOR
	CALL BACKUP	;FORMAT ADD r
S77C:	CALL GNC	;FETCH SOURCE REG
	CPI '('
	JZ S85 		;BRANCH IF () FORM
	LHLD PTR1
	CPI 27H
	JZ S77B		;PROCESS CHAR
	CPI 30H		;TEST IF IMMED
	JC S24A		;ABORT, ERROR
	CPI ':'
	JC S77B		;PROCESS IMMEDIATE
S77D:	INX H
	MOV A,M
	CPI ','
	JZ S96A		;BRANCH IF REGISTER PAIR
	DCX H
S77B:	DCX H
	SHLD PTR1
	CALL EVAL
	LDA EVFLGS
	ANI RNAME
	JNZ S84
	LDA OPCODE
	ADI 0C6H
	STA INST
	LDA VAL
	STA INST+1
	MVI A,2
	STA LEN
	JMP ENDSTMT
;
;	PROCESS REGISTER NAME
;
S84	EQU	$
	LDA OPCODE
	ADI 80H
	MOV B,A
	LDA VAL
	ADD B
	STA INST
	MVI A,1
	STA LEN
	JMP ENDSTMT
;
S85	EQU	$
	CALL GNC
	CALL GNC
	CPI 'L'
	CZ S131		;CHECK HL ONLY
	JZ S95		;PROCESS AS (HL)
	CPI 'Y'
	STA IXFLAG	;MARK AS INDEX
	CZ S131		;CHECK IY+
	JZ S93		;PROCESS AS (IY)
	CALL S131	;CHECK IX+
	JNZ S24A	;ERROR EXIT
	MVI A,0DDH	;PROCESS AS (IX)
	STA INST
S88	EQU	$
	LDA OPCODE
	ADI 86H
	STA INST+1
	MVI A,3
	STA LEN
	CALL GNC
	CALL EVAL
	CALL GNC	;BYPASS )
	LDA VAL
	STA INST+2
	JMP ENDSTMT
;
S93	EQU	$
	MVI A,0FDH
	STA INST
	JMP S88
;
S95	EQU	$
	CALL GNC
	CALL GNC	;BYPASS )
	LDA OPCODE
	ADI 86H
	STA INST
	MVI A,1
	STA LEN
	JMP ENDSTMT
;
;	PROCESS REGISTER PAIR ADD,SUB,ADC,SBC
;
S96A	EQU	$
	CALL BACKUP
	CALL EVAL
	LDA UFLAG	;VALID LABEL  ?
	ORA A
	JNZ S24A	;ERROR EXIT
	LDA VAL
	CPI 0FFH 	;IX
	JZ S96H
	CPI 0FEH 	;IY
	JZ S96J
	LDA OPCODE+1
	CPI 9
	JZ S96F
	MVI A,0EDH
	STA INST
	MVI A,2
	STA LEN
	CALL EVAL
	LDA VAL
	RLC
	RLC
	RLC
	ANI 38H
	MOV B,A
	LDA OPCODE+1
	ADD B
	STA INST+1
	JMP ENDSTMT
;
S96F	EQU	$
	CALL EVAL
	LDA VAL
	RLC
	RLC
	RLC
	ANI 38H
	MOV B,A
	LDA OPCODE+1
	ADD B
	STA INST
	MVI A,1
	STA LEN
	JMP ENDSTMT
;
S96H 	EQU	$
	MVI A,0DDH
	STA INST
	CALL EVAL
	LDA VAL
	CPI 0FEH
	JZ S24A		;ERROR
	JMP S96K
;
S96J	EQU	$
	MVI A,0FDH
	STA INST
	CALL EVAL
	LDA VAL
	CPI 0FFH
	JZ S24A		;ERROR
S96K:	ANI 0FEH
	CPI 0FEH
	JZ S96M
	CPI 7
	JNC S24A	;ERROR
	JMP S96L
;
S96M:	MVI A,4
	STA VAL
S96L	EQU	$
	LDA VAL
	RLC
	RLC
	RLC
	ANI 38H
	MOV B,A
	LDA OPCODE+1
	ADD B
	STA INST+1
	MVI A,2
	STA LEN
	JMP ENDSTMT
;
;	CLASS 7 - I/O INSTRUCTIONS
;
S97	EQU	$
	LDA OPCODE
	CPI 0D3H
	JZ S107 	;BRANCH IF OUT OPCODE
	CALL GNC
	CPI 'A'
	JNZ S104 	;BRANCH IF NOT 8080 TYPE I/O
	LHLD PTR1
	INX H
	INX H
	MOV A,M
	CPI 'C'
	JZ S104		;STILL NOT 8080
	CALL GNC
	CPI ','
	JNZ S24A
	CALL GNC
	CPI '('
	JNZ S24A
	CALL EVAL 	;GET PORT ADDRESS
	CALL GNC	;BYPASS )
	MVI A,0DBH
	STA INST
	LDA VAL
	JMP S113
;
S104	EQU	$
	CALL BACKUP
	CALL EVAL	;GET REGISTER NAME
S104B:	MVI A,0EDH
	STA INST
	CALL GNC
	CALL GNC	;GET REGISTER
	CPI 'C'
	JNZ S24A
	CALL GNC
	CALL GNC
	LDA VAL
	RLC
	RLC
	RLC
	ANI 38H
	ADI 40H
	JMP S113
;
S107	EQU	$	;PROCESS OUT INSTRUCTION
	CALL GNC
	CPI '('
	JNZ S24A
	CALL GNC
	CPI 'C'
	JNZ S109
	LHLD PTR1
	MOV A,M
	CPI ')'
	JZ S112
S109	EQU	$
	CALL BACKUP
	CALL EVAL	;GET PORT NUMBER
	CALL GNC	;BYPASS )
	CALL GNC
	CPI 'A'
	JNZ S24A
	CALL GNC
	MVI A,0D3H
	STA INST
	LDA VAL
	JMP S113
;
S112	EQU	$
	CALL GNC
	CALL GNC
	CPI ','
	JNZ S24A
	CALL EVAL
	MVI A,0EDH
	STA INST
	LDA VAL
	RLC
	RLC
	RLC
	ANI 38H
	ADI 41H
S113:	STA INST+1
	MVI A,2
	STA LEN
	JMP ENDSTMT
;
;
;	CLASS 8 - LD INSTRUCTIONS
;
;	THE FOLLOWING ARE STRINGS WHICH ARE SPECIAL OPERAND FORMS
;
LD1	DB	'A,I'
LD2	DB	'A,R'
LD3	DB	'I,A'
LD4	DB	'R,A'
LD5	DB	'SP,HL'
LD6	DB	'SP,IX'
LD7	DB	'SP,IY'
;
S116	EQU	$
	CALL GNC
	CALL BACKUP 	;POINT TO OPERAND FIELD
	LHLD PTR1 	;SET UP POINTER TO OPERAND FIELD
	LXI D,LD1
	MVI B,3
	CALL S117
	JZ S171
	LXI D,LD2
	MVI B,3
	CALL S117
	JZ S173
	LXI D,LD3
	MVI B,3
	CALL S117
	JZ S175
	LXI D,LD4
	MVI B,3
	CALL S117
	JZ S177
	LXI D,LD5
	MVI B,5
	CALL CMPCHR
	JZ S179
	LXI D,LD6
	MVI B,5
	CALL CMPCHR
	JZ S181
	LXI D,LD7
	MVI B,5
	CALL CMPCHR
	JZ S183 	;PROCESS SPECIAL OPRNDS
;
	CALL GNC
	CPI '('
	JZ S186 	;BRANCH IF () FORM
	CALL BACKUP
	CALL EVAL
	LDA UFLAG	;VALID NAME ?
	ORA A
	JNZ S24A	;ERROR EXIT
	LDA EVFLGS
	ANI ULBL
	JNZ S24A	;LABEL ILLEGAL HERE
	LDA EVFLGS
	ANI RPNAME
	JNZ S147	;BRANCH IF RPAIR NAME
	CALL GNC
	CPI '('
	JZ S130 	;BRANCH IF () OPERAND
	LHLD VAL
	SHLD SAVVAL
	CPI 27H
	JZ S116A
	CPI '0'
	JC S24A
S116A:	CALL BACKUP
	CALL EVAL
	LDA EVFLGS
	ANI RNAME
	JNZ S128 	;> RNAME
	LDA SAVVAL
	RLC
	RLC
	RLC
	ANI 38H
	ADI 6
	STA INST
	LDA VAL
	STA INST+1
	MVI A,2
	STA LEN
	JMP ENDSTMT 	;IMMED OPERAND
;
S117	EQU	$
	CALL CMPCHR	;TEST FOR MATCH
	RNZ		;NONE, EXIT
	PUSH B		;SAVE REGS
	PUSH H
	MOV C,B		;FETCH LENGTH
	MVI B,0H	;16 BITS
	DAD B		;MAKE PTR NEXT CHAR
	MOV A,M		;FETCH NEXT CHAR
	POP H		;RECOVER REGS
	POP B
	CPI ' '		;BLANK ?
	RZ		;VALID MATCH
	CPI 0DH		;END OF LINE ?
	RZ		;VALID MATCH
	XRA A		;MAKE CERTAIN NON-ZERO ..
	INR A		;..SIGNALS NO MATCH
	RET
;
S128	EQU	$	;PROCESS RNAME
	LDA SAVVAL
	RLC
	RLC
	RLC
	ANI 38H
	MOV B,A
	LDA VAL
	ADD B 
	ADI 40H		;FOR R-R TYPE INST
	STA INST
	MVI A,1
	STA LEN 	;REG-REG OPERAND
	JMP ENDSTMT
;
S130	EQU	$
	CALL GNC	;LOOK 1ST CHAR AFTER (
	CALL GNC	;LOOK 2ND CHAR AFTER (
	CPI 'L'
	CZ S131		;CHECK IS HL ONLY
	JZ S138
	CPI 'X'
	STA IXFLAG	;MARK AS INDEX
	CZ S131		;CHECK IX+ ONLY
	JZ S140
	CALL S131	;CHECK IY+ ONLY
	JZ S145
	JC S24A		;ERROR EXIT
	ORA A
	JNZ S130A	;NOT A LABEL
	STA IXFLAG	;LABEL, NOT INDEX
S130A:	CALL BACKUP
	CALL BACKUP
	CALL EVAL
	LDA EVFLGS
	ANI RPNAME
	JNZ S136 	;BRANCH IF REG PAIR
	MVI A,3AH
	STA INST
	LHLD VAL
	SHLD INST+1
	MVI A,3
	STA LEN
	CALL GNC	;BYPASS )
	JMP ENDSTMT
;
S131:	PUSH H		;SAVE REGS
	PUSH D
	PUSH B
	LHLD PTR1	;FETCH TEXT PTR
	DCX H		;STEP BACK TO 1ST CHAR AFTER (
	DCX H
	LXI D,LD01	;PTR TO 'HL)'
	MVI B,3H	;CHARS TO COMPARE COUNT
	CALL CMPCHR	;TEST
	JZ S133		;FOUND
	LXI D,LD02	;PTR TO IX+
	MVI B,3H	;COUNT
	CALL CMPCHR	;TEST
	JZ S133		;FOUND
	LXI D,LD03	;PTR TO IY+
	MVI B,3H	;COUNT
	CALL CMPCHR	;TEST
	JZ S133		;FOUND
	INX H		;RESTORE PTR
	INX H
	MOV A,M		;FETCH NEXT CHAR
	ANI 0FBH	;MASK - OR ) TO ) [IX- = ILLEGAL]
	CPI ')'		;TERMINATOR OR - ?
	MVI A,0H	;MARK AS POSSIBLE LABEL
	JNZ S133	;POSS LABEL
	DCX H		;PTR TO CHAR BEFORE )
	MOV A,M
	ANI 0FEH	;MASK FOR X OR Y
	CPI 58H		;X OR Y ?
	MVI A,0H	;MARK AS POSSIBLE LABEL
	JNZ S133	;VALID REG PAIR
	XRA A
	INR A		;MARK AS NOT FOUND
	STC		;MARK AS ERROR
	JMP S132	;INVALID
;
S133:	STC		;CLEAR CARRY = NO ERROR
	CMC
S132:	POP B		;RECOVER REGS
	POP D
	POP H
	RET		;DONE, Z=1 IF MATCHED ANY ONE
;
S136	EQU	$
	LDA VAL
	RLC
	RLC
	RLC
	ANI 38H
	ADI 0AH
	STA INST
	MVI A,1
	STA LEN
	CALL GNC
	JMP ENDSTMT
;
S138	EQU	$
	LDA VAL
	RLC
	RLC
	RLC
	ANI 38H
	ADI 46H
	STA INST
	MVI A,1
	STA LEN
	CALL GNC
	CALL GNC	;BYPASS )
	JMP ENDSTMT
;
S140:	MVI A,0DDH
	STA INST
S140A:	LDA VAL
	RLC
	RLC
	RLC
	ANI 38H
	ADI 46H
	STA INST+1
	CALL GNC
	CALL EVAL
	LDA VAL
	STA INST+2
	MVI A,3
	STA LEN
	CALL GNC	;BYPASS )
	JMP ENDSTMT
;
S145	EQU	$
	MVI A,0FDH
	STA INST
	JMP S140A
;
S147	EQU	$
	CALL GNC
	CPI '('
	JZ S159
	LHLD VAL
	SHLD SAVVAL
	CPI 27H
	JZ S147A
	CPI '0'
	JC S24A
S147A:	CALL BACKUP
	CALL EVAL
	LDA SAVVAL
	CPI 0FFH
	JZ S155
	CPI 0FEH
	JZ S157
	LDA SAVVAL
	RLC
	RLC
	RLC
	ANI 38H
	INR A
	STA INST
	LHLD VAL
	SHLD INST+1
	MVI A,3
	STA LEN
	JMP ENDSTMT
;
S155	EQU	$
	MVI A,0DDH
	STA INST
S156	EQU	$
	MVI A,21H
	STA INST+1
	MVI A,4
	STA LEN
	LHLD VAL
	SHLD INST+2
	JMP ENDSTMT
;
S157	EQU	$
	MVI A,0FDH
	STA INST
	JMP S156
;
S159	EQU	$
	LHLD VAL
	SHLD SAVVAL 
	CALL EVAL
	LDA SAVVAL
	CPI 4
	JZ S165
	CPI 0FFH
	JZ S167
	CPI 0FEH
	JZ S169
	MVI A,0EDH
	STA INST
	LDA SAVVAL
	RLC
	RLC
	RLC
	ANI 38H
	ADI 4BH
	STA INST+1
	LHLD VAL
	SHLD INST+2
	MVI A,4
	STA LEN
	CALL GNC	;BYPASS )
	JMP ENDSTMT
;
S165	EQU	$
	MVI A,2AH
	STA INST
	LHLD VAL
	SHLD INST+1
	MVI A,3
	STA LEN
	CALL GNC	;BYPASS )
	JMP ENDSTMT
;
S167	EQU	$
	MVI A,0DDH
	STA INST
S168:	MVI A,2AH
	STA INST+1
	LHLD VAL
	SHLD INST+2
	MVI A,4
	STA LEN
	CALL GNC
	JMP ENDSTMT
;
S169	EQU	$
	MVI A,0FDH
	STA INST
	JMP S168
;
S171:	LXI H,57EDH
S171A:	SHLD INST
	MVI A,2
	STA LEN
TSKIP1:	LHLD PTR1
	ADD B
	MOV E,A
	MVI D,0
	DAD D
	SHLD PTR1
	JMP ENDSTMT
;
S173:	LXI H,5FEDH
	JMP S171A
;
S175:	LXI H,47EDH
	JMP S171A
;
S177:	LXI H,4FEDH
	JMP S171A
;
S179:	MVI A,0F9H
	STA INST
	MVI A,1
	STA LEN
	MVI A,2
	JMP TSKIP1
;
S181:	LXI H,0F9DDH
	JMP S171A
;
S183:	LXI H,0F9FDH
	JMP S171A
;
LD01:	DB	'HL)'
LD02:	DB	'IX+'
LD03:	DB	'IY+'
;
S186:	CALL GNC	;1ST CHAR AFTER (
	CALL GNC	;2ND CHAR AFTER (
	CPI 'L'
	CZ S131		;TEST HL ONLY
	JZ S204		;PROCESS AS (HL)
	CPI 'X'
	STA IXFLAG	;MARK AS INDEX
	CZ S131		;TEST IX+
	JZ S210A	;PROCESS AS (IX)
	CALL S131	;TEST IY+
	JZ S210B	;PROCESS AS (IY)
	JC S24A		;ERROR EXIT
	ORA A
	JNZ S186A	;NOT A LABEL
	STA IXFLAG	;LABEL, NOT INDEX
S186A:	CALL BACKUP	;RESTORE TEXT PTR
	CALL BACKUP
	CALL EVAL
	LHLD VAL
	SHLD SAVVAL
	LDA EVFLGS
	ANI RPNAME
	JNZ S202	;PROCESS AS REG PAIR
	CALL GNC	;BYPASS COMMA
	CALL EVAL
	LDA EVFLGS
	ANI RPNAME
	JNZ S193
S187:	MVI A,32H
	STA INST
	LHLD SAVVAL
	SHLD INST+1 
	MVI A,3
	STA LEN
	JMP ENDSTMT
;
S193	EQU	$
	LDA VAL
	CPI 4
	JZ S196
	CPI 0FFH
	JZ S198
	CPI 0FEH
	JZ S200
	MVI A,0EDH
	STA INST
	LDA VAL
	RLC
	RLC
	RLC
	ANI 38H
	ADI 43H
	STA INST+1
	LHLD SAVVAL
	SHLD INST+2
	MVI A,4
	STA LEN
	JMP ENDSTMT
;
S196	EQU	$
	MVI A,22H
	STA INST
	LHLD SAVVAL
	SHLD INST+1
	MVI A,3
	STA LEN
	JMP ENDSTMT
;
S198	EQU	$
	MVI A,0DDH
	STA INST
S199	EQU	$
	MVI A,22H
	STA INST+1
	LHLD SAVVAL
	SHLD INST+2
	MVI A,4
	STA LEN
	JMP ENDSTMT
;
S200	EQU	$
	MVI A,0FDH
	STA INST
	JMP S199
;
S202	EQU	$
	CALL GNC	;BY-PASS COMMA
	CALL GNC	;FETCH REG
	CPI 'A'		;A REG ONLY
	JNZ S24A	;ERROR EXIT
	LDA VAL
	RLC
	RLC
	RLC
	ANI 38H
	ADI 2
	STA INST
	MVI A,1
	STA LEN
	CALL GNC
	JMP ENDSTMT
;
S204	EQU	$
	CALL GNC
	CALL GNC
	CALL EVAL
	LDA EVFLGS
	ANI RNAME
	JNZ S209
	MVI A,36H
	STA INST
	LDA VAL
	STA INST+1
	MVI A,2
	STA LEN
	JMP ENDSTMT
;
S209	EQU	$
	LDA VAL
	ADI 70H
	STA INST
	MVI A,1
	STA LEN
	JMP ENDSTMT
;
S210A:	MVI A,0DDH
	STA INST
	JMP S211
;
S210B:	MVI A,0FDH
	STA INST
S211	EQU	$
	CALL GNC
	CALL EVAL
	LHLD VAL
	SHLD SAVVAL
	CALL GNC	;BYPASS COMMA
	CALL EVAL
	LDA EVFLGS
	ANI RNAME
	JNZ S218
S212:	MVI A,36H
	STA INST+1
	LDA SAVVAL
	STA INST+2
	LDA VAL
	STA INST+3
	MVI A,4
	STA LEN
	JMP ENDSTMT
;
S218	EQU	$
	LDA VAL
	ADI 70H
	STA INST+1
	LDA SAVVAL
	STA INST+2
	MVI A,3
	STA LEN
	JMP ENDSTMT
;
;	CLASS 9 - PUSH POP
;
S220	EQU	$
	CALL EVAL
	LDA VAL
	CPI 0FFH
	JZ S224
	CPI 0FEH
	JZ S226
	LDA VAL
	RLC
	RLC
	RLC
	ANI 38H
	MOV B,A
	LDA OPCODE
	ADD B
	STA INST
	MVI A,1
	STA LEN
	JMP ENDSTMT
;
S224	EQU	$
	MVI A,0DDH
	STA INST
S225	EQU	$
	LDA OPCODE
	ADI 20H
	STA INST+1
	MVI A,2
	STA LEN
	JMP ENDSTMT
;
S226:	MVI A,0FDH
	STA INST
	JMP S225
;
;	CLASS 10 - EXCHANGE (EX)
;
EXD1:	DB	'DE,HL'
EXD2:	DB	'AF,AF'''
EXD3:	DB	'SP),HL'
EXD4:	DB	'SP),IY'
EXD5:	DB	'SP),IX'
;
S228	EQU	$
	CALL GNC
	CPI '('
	JZ S235 	;BRANCH IF () FORM
	LHLD PTR1
	DCX H		;PTR TO FIRST CHAR
	CPI 'A'
	JZ S233 	;BRANCH IF EX AF,AF'
	LXI D,EXD1
	MVI B,5
	CALL TSKIP
	MVI A,0EBH
S229:	STA INST
	MVI A,1
	STA LEN
	JMP ENDSTMT
;
S233	EQU	$
	LXI D,EXD2
	MVI B,6
	CALL TSKIP
	MVI A,8
	JMP S229
;
S235	EQU	$
	LHLD PTR1
	PUSH H
	LXI D,5
	DAD D
	SHLD PTR1
	CALL GNC
	POP H
	CPI 'L'
	JZ S239
	CPI 'Y'
	JZ S241
	LXI D,EXD5
	MVI B,6
	CALL TSKIP
	MVI A,0DDH
	STA INST
S238	EQU	$
	MVI A,0E3H
	STA INST+1
	MVI A,2
	STA LEN
	JMP ENDSTMT
;
S239	EQU	$
	LXI D,EXD3
	MVI B,6
	CALL TSKIP
	MVI A,0E3H
	JMP S229
;
S241	EQU	$
	LXI D,EXD4
	MVI B,6
	CALL TSKIP
	MVI A,0FDH
	STA INST
	JMP S238
;
TSKIP:	CALL CMPCHR
	INX H
	MVI D,0H
	MOV E,B
	DAD D
	SHLD PTR1
	RZ		;VALID
	POP H		;WASTE STACK
	JMP S24A	;ERROR
;	CLASS 11 - RETURNS
;
S243	EQU	$
	CALL GNC 
	CPI 0AH
	JZ S248		;BRANCH IF NO OPERAND
	CPI 0DH
	JZ S248
	CPI ';'
	JZ S248 	;BRANCH IF NO OPERAND
	LHLD SYMCND
	SHLD SYMPT 	;FOR ELIMINATING REG NAME CONFLICTS
	CALL BACKUP
	CALL EVAL
	LXI H,SYM
	SHLD SYMPT 	;PUT IT BACK
	LDA VAL
	RLC
	RLC
	RLC
	ANI 38H
	ADI 0C0H
	STA INST
	MVI A,1
	STA LEN
	JMP ENDSTMT
;
S248	EQU	$
	LDA OPCODE
	STA INST
	MVI A,1
	STA LEN
	JMP ENDSTMT
;
;	CLASS 12 - BIT,SET,RES
;
S250	EQU	$
	CALL EVAL
	LHLD VAL
	SHLD SAVVAL 	;SAVE BIT NUMBER
	CALL GNC
	CPI '('
	JZ S257
	CALL BACKUP
	CALL EVAL
	MVI A,0CBH
	STA INST
	LDA SAVVAL
	RLC
	RLC
	RLC
	ANI 38H
	MOV B,A
	LDA OPCODE
	ADD B
	MOV B,A
	LDA VAL
	ADD B
	STA INST+1
	MVI A,2
	STA LEN
	JMP ENDSTMT
;
S257	EQU	$
	CALL GNC
	CALL GNC
	CPI 'L'
	CZ S131		;CHECK ONLY HL
	JZ S266		;PROCESS AS (HL)
	CPI 'Y'
	STA IXFLAG	;MARK AS INDEX
	CZ S131		;CHECK IY+ ONLY
	JZ S264		;PROCESS AS (IY)
	CALL S131	;CHECK IX+ ONLY
	JNZ S24A	;ERROR EXIT
	MVI A,0DDH	;PROCESS AS (IX)
	STA INST
S260:	CALL GNC
	CALL EVAL
	MVI A,0CBH
	STA INST+1
	LDA VAL
	STA INST+2
	LDA SAVVAL
	RLC
	RLC
	RLC
	ANI 38H
	ADI 6
	MOV B,A 
	LDA OPCODE
	ADD B
	STA INST+3
	MVI A,4
	STA LEN
	CALL GNC	;BYPASS )
	JMP ENDSTMT
;
S264	EQU	$
	MVI A,0FDH
	STA INST
	JMP S260
;
S266	EQU	$
	MVI A,0CBH
	STA INST
	LDA SAVVAL
	RLC
	RLC
	RLC
	ANI 38H
	ADI 6
	MOV B,A
	LDA OPCODE
	ADD B
	STA INST+1
	MVI A,2
	STA LEN
	CALL GNC
	CALL GNC	;BYPASS )
	JMP ENDSTMT
;
;	CLASS 13 - INC,DEC
;
S268	EQU	$
	CALL GNC
	CPI '('
	JZ S290
	CALL BACKUP
	CALL EVAL
	LDA EVFLGS
	ANI RNAME
	JNZ S280
	LDA VAL
	CPI 0FFH
	JZ S275
	CPI 0FEH
	JZ S278
	LDA VAL
	RLC
	RLC
	RLC
	ANI 38H
	MOV B,A
	LDA OPCODE+1
	ADD B
	STA INST
	MVI A,1
	STA LEN
	JMP ENDSTMT
;
S275:	MVI A,0DDH
	STA INST
S276:	LDA OPCODE+1
	ADI 20H
	STA INST+1
	MVI A,2
	STA LEN 
	JMP ENDSTMT
;
S278	EQU	$
	MVI A,0FDH
	STA INST
	JMP S276
;
S280	EQU	$
	LDA VAL
	RLC
	RLC
	RLC
	ANI 38H
	MOV B,A
	LDA OPCODE
	ADD B
	STA INST
	MVI A,1
	STA LEN
	JMP ENDSTMT
;
S290	EQU	$
	CALL GNC
	CALL GNC
	CPI 'L'
	CZ S131		;CHECK ONLY HL
	JZ S299		;PROCESS AS (HL)
	CPI 'Y'
	STA IXFLAG	;MARK AS INDEX
	CZ S131		;CHECK IY+ ONLY
	JZ S297		;PROCESS AS (IY)
	CALL S131	;CHECK IX+ ONLY
	JNZ S24A	;ERROR EXIT
	MVI A,0DDH	;PROCESS AS (IX)
	STA INST
S293:	CALL GNC
	CALL EVAL
	LDA OPCODE
	ADI 30H
	STA INST+1
	LDA VAL
	STA INST+2
	MVI A,3
	STA LEN
	CALL GNC	;BYPASS )
	JMP ENDSTMT
;
S297	EQU	$
	MVI A,0FDH
	STA INST
	JMP S293
;
S299	EQU	$
	LDA OPCODE
	ADI 30H
	STA INST
	MVI A,1
	STA LEN
	CALL GNC
	CALL GNC	;BYPASS )
	JMP ENDSTMT
;
;	CLASS 14 - PSEUDO OPERATORS
;
S301	EQU	$
	LDA OPCODE
	DCR A
	ADD A
	MOV E,A
	MVI D,0
	LXI H,PSDTAB
	DAD D
	MOV E,M
	INX H
	MOV D,M
	XCHG
	PCHL
;
PSDTAB	EQU	$
	DW	S302	;EQU
	DW	S305	;DEFS
	DW	S308	;DEFB
	DW	S317	;DEFW
	DW	S320	;END
	DW	S323	;ORG
	DW	S324	;EJECT
;
S302	EQU	$	;EQU
	CALL EVAL
	LDA PASSNO	;TEST FOR PASS 2
	ORA A
	JNZ S302B	;DON'T ENTER AGAIN
	LHLD VAL
	XCHG
	LHLD SYMADR
	MOV M,E
	INX H
	MOV M,D
	DCX H		;DECR PTR TO LAST IN LABEL
S302C:	DCX H		;DECR LABEL PTR
	MOV A,M		;FETCH CHAR
	ORA A		;TERMINATOR ?
	JNZ S302C	;MORE IN LABEL
	INX H		;INCR PTR TO IDENTITY
	MOV A,M		;FETCH IDENTITY
	ANI 0FH		;CLEAR LABEL FLAG
	ORI 10H		;MARK AS EQUATE LABEL
	MOV M,A		;SAVE BACK
S302B:	LHLD VAL
	SHLD EQUVAL
	MVI A,1
	STA EQUFLG
	JMP ENDSTMT
;
S305	EQU	$	;DEFS
	CALL EVAL
	LHLD VAL
	SHLD LEN2
	JMP ENDSTMT
;
S308	EQU	$	;DEFB
	CALL GNC
	LXI D,INST
	LHLD PTR1
S308A:	CPI 27H
	JNZ S308C 	;BRANCH IF NO QUOTE
	INX H		;INCR PTR
	MOV A,M		;FETCH NEXT CHAR
	CPI 27H		;TEST IF SINGLE CHAR IN QOUTES
	DCX H		;STEP PTR BACK
	JNZ S313	;PROCESS AS STRING IN QUOTES
S308C:	DCX H		;PTR TO PREV CHAR
	SHLD PTR1	;RESTORE NEW PTR
	PUSH D		;SAVE PTR TO INST STORE
	CALL EVAL
	POP D		;RECOVER PTR
	LDA VAL
	STAX D		;SAVE VALUE IN STORE
	INX D		;INCR PTR
	LDA LEN		;FETCH LENGTH COUNT
	INR A		;INCR COUNT
	STA LEN		;SAVE NEW COUNT
	LHLD PTR1	;RECOVER RECORD PTR
	DCX H		;SET PTR BACK
S308B:	MOV A,M		;FETCH NEXT CHAR FROM RECORD
	CPI 9H
	JZ TABSKP	;SKIP OVER TABS
	CPI ' '
	JZ SPCSKP	;SKIP SPACES
	SHLD PTR1
	CPI 0DH		;END OF RECORD ?
	JZ S309		;DONE
	CPI ';'		;COMMENT SEPARATOR ?
	JZ S309		;IGNORE REST OF LINE
	CPI ','		;SEPARATOR ?
	INX H		;PTR TO NEXT CHAR
	MOV A,M		;FETCH NEXT CHAR
	SHLD PTR1	;SAVE RECORD PTR
	INX H		;INCR PTR FOR STRING
	JZ S308A	;PROCESS NEXT
	JMP DEBEND	;EXPRESSION ERROR
;
S309:	CALL GNC
	JMP ENDSTMT
;
S313	EQU	$
	LDA LEN
	INR A
	STA LEN
	MOV A,M
	STAX D
	INX D
	INX H
	MOV A,M
	CPI 27H
	JNZ S313   
	INX H		;INCR RECORD PTR
	MOV A,M
	CPI 27H
	JZ S313		;DOUBLE QUOTES
	JMP S308B	;PROCESS TERMINATOR/SEPARATORS
;
DEBEND:	MVI A,'E'	;LOAD EXPRESSION ERROR
	STA ERRFLG	;SET FLAG
	JMP ENDSTMT	;DONE
;
TABSKP:	INX H		;STEP PTR PAST TAB
	MOV A,M		;FETCH NEXT CHAR
	CPI 9H		;H.TAB ?
	JZ TABSKP	;LOOP
	SHLD PTR1	;SAVE NEW PTR
	JMP S308B	;PROCESS NEXT
;
SPCSKP:	INX H		;STEP PTR PAST SPACE
	MOV A,M		;FETCH NEXT CHAR
	CPI 20H		;ASCII SPACE ?
	JZ SPCSKP	;LOOP
	SHLD PTR1	;SAVE NEW PTR
	JMP S308B	;PROCESS NEXT
;
S317	EQU	$	;DEFW
	CALL EVAL
	LHLD VAL
	SHLD INST
	MVI A,2
	STA LEN
	JMP ENDSTMT
;
S320	EQU	$	;END
	CALL EVAL
	LHLD VAL
	MOV A,H		;TEST IF NO VALUE
	ORA L
	LHLD PC		;FETCH PC IN CASE
	JZ S320A	;NO VALUE
	LHLD VAL	;FETCH REAL VALUE
S320A:	SHLD ENDADR
	SHLD EQUVAL 
S321:	MVI A,1
	STA EQUFLG
	STA EFLG
	JMP ENDSTMT
;
S323	EQU	$	;ORG
	CALL EVAL
	LHLD VAL
	SHLD PC
	SHLD EQUVAL
	MVI A,1
	STA EQUFLG
	JMP ENDSTMT
;
S324	EQU	$	;EJECT
	MVI A,MAXLNE-1
	STA CURLNE 	;CAUSE HOF ON RECORD AFTER EJECT
;
;
;	E N D   O F   S T A T E M E N T   P R O C E S S I N G
;
;	ENDSTMT------HERE IT IS !!!
;
;
ENDSTMT	EQU	$
	LHLD PTR1	;CHECK VALID TERMINATORS
	DCX H		;STEP BACK TO LAST CHAR
	MOV A,M
S400A:	CPI ' '
	JZ S400
	CPI 09H
	JZ S400
	CPI ';'
	JZ S401A
	CPI 0DH
	JZ S401A
	CPI 0AH
	JZ S401A
	JMP S401	;PROBABLE ERROR
;
S400:	CALL GNC
	JMP S400A	;SKIP TABS/SPACES
;
S401:	LDA ERRFLG
	CPI ' '
	JNZ S401A	;ERROR ALREADY, LEAVE IT
	MVI A,'O'
	STA ERRFLG
S401A:	LDA PASSNO
	ORA A
	JZ S417		;DONT PRINT DURING PASS 1
	LDA UFLAG
	ORA A
	JZ $+8
	MVI A,'U'
	STA ERRFLG
	XRA A
	STA UFLAG
	LDA ERRFLG
	CPI ' '
	JNZ S402 	;ALWAYS PRINT ERRORS
	LDA LFLAG
	CPI 'Z'
	JZ S412 	;DON'T PRINT IF USER ASKED US NOT TO
S402	EQU	$
	LDA ERRFLG
	CPI ' '		;TEST FOR ERROR
	JZ S402A	;OK, SKIP COUNT
	PUSH PSW	;SAVE ERROR
	LDA ERCNT	;FETCH ERROR COUNT
	ADI 1		;INCR COUNT
	DAA		;DECIMAL COUNT
	STA ERCNT
	POP PSW
S402A:	STA HDRBUF
	MVI A,' '
	STA HDRBUF+1
	LXI H,HDRBUF+2
	LXI D,HDRBUF+1
	LXI B,14
	CALL MOVE
	LDA EQUFLG
	ORA A
	MVI A,0H
	STA EQUFLG	;CLEAR EQUATE FLAG
	JNZ S410 	;BRANCH IF TO USE EQUVAL
	LHLD PC
	XCHG
	LXI H,HDRBUF+1
	MOV A,D
	CALL CNV2HX
	MOV A,E
	CALL CNV2HX
	INX H
	LXI D,INST
	MVI C,4
	LDA LEN
	MOV B,A
	ORA A
	JZ S408		;BRANCH IF LENGTH IF ZERO
S406	EQU	$
	LDAX D
	CALL CNV2HX
	INX D
	DCR B
	JZ S408
	DCR C
	JNZ S406
S408	EQU	$
	JMP S410A
;
S410	EQU	$
	LHLD EQUVAL
	XCHG
	LXI H,HDRBUF+1
	MOV A,D
	CALL CNV2HX
	MOV A,E
	CALL CNV2HX
	MVI M,20H
	INX H
	MVI M,3DH
S410A:	LXI H,HDRBUF
	CALL PLINE 	;WRITE AND PAGE
;
S412	EQU	$
	LDA LEN
	ORA A
	JZ S417
	MOV B,A
	LXI D,INST
	LHLD PC
	SHLD TEMP
S414	EQU	$
	PUSH B
	LDAX D
	LHLD TEMP
	CALL WOBJ
	POP B
	INX D
	LHLD TEMP
	INX H
	SHLD TEMP
	DCR B
	JNZ S414
S417	EQU	$
	LHLD PC
	LDA LEN
	MOV C,A
	MVI B,0
	DAD B
	XCHG
	LHLD LEN2
	DAD D
	SHLD PC
	LDA EFLG
	ORA A
	JZ NEXT 	;GO PROCESS NEXT RECORD
	LDA PASSNO
	CMA
	STA PASSNO
	CPI 0
	JZ ENDIT
	LXI H,FCB1+12
	MVI M,0
	LXI D,FCB1
	CALL OPNFIL
	LXI H,FCB1+32
	MVI M,0
	LXI H,INBUF+1024
	SHLD IBP
	XRA A
	STA EFLG	;RESET END OF RECORD FLAG
	LXI H,0
	SHLD PC		;RESET PC
	MVI A,1
	STA PAGENO	;SET UP PAGE NUMBER
	MVI A,0H
	STA CURLNE
	SHLD OBJADR
	LDA LFLAG
	CPI 'P'+1
	JNC S417A	;SKIP PAGING IF PRINTER NOT ASKED FOR
	PUSH PSW	;SAVE FLAGS
	CALL HOFLNE	;FORM HEADER
	POP PSW		;RECOVER FLAGS
	LXI H,HOFMSG	;1ST. HEADER
	CALL PLINE2
	LDA CURLNE
	INR A
	STA CURLNE
S417A:	LXI D,-1
	JMP NEXT	;PROCESS ANOTHER RECORD

;
ENDIT	EQU	$
	LDA HFLAG
	CPI 'Z'
	JZ ENDITX	;BRANCH IF NO HEX FILE
	LDA OBJCNT
	ORA A
	JZ ENDIT1 	;BRANCH IF NO OBJ TO WRITE
	CALL WREC	;ELSE WRITE FINAL RECORD
ENDIT1:	LXI H,EOFREC
	MVI B,13
ENDIT2:	MOV A,M
	CALL WNB2
	INX H
	DCR B
	JNZ ENDIT2
	MVI B,255	;FLUSH BUFFER
ENDIT3:	MVI A,1AH
	CALL WNB2
	DCR B
	JNZ ENDIT3
	LXI D,FCB2
	CALL CLSFIL
ENDITX	EQU	$
	LXI H,ERMSGA	;PTR TO COUNTER
	LDA ERCNT	;FETCH ERRORS
	CALL CNV2HX	;MAKE HEX
	LXI H,HDRBUF	;PTR TO OUTPUT BUFFER
	LXI D,ERMSGA	;PTR TO MESSAGE
	LXI B,0CH	;LOAD ERROR MESSAGE COUNT
	MOV A,C		;SET ERRORS FLAG TO FORCE PRINTING
	STA ERRFLG	;
	CALL MOVE	;SHIFT TO OP BUFFER
	CALL PLINE	;PRINT ERRORS
	MVI A,' '	;CLEAR ERROR FLAG
	STA ERRFLG	;
	LHLD PC
	XCHG
	LXI H,PCMSGA
	MOV A,D
	CALL CNV2HX
	MOV A,E
	CALL CNV2HX
	LXI H,HDRBUF
	LXI D,PCMSG
	LXI B,18H	;CHAR COUNT
	CALL MOVE	;TO OP BUFFER
	CALL PLINE
	LXI H,HDRBUF
	LXI D,ENDMSG
	LXI B,1CH
	CALL MOVE
	CALL PLINE
ENDITP:	LDA LFLAG
	CPI 46H		;FILE ASKED FOR ?
	JNC ENDALL	;BRANCH, NO FILE TO CLOSE
	MVI B,255
ENDIT4:	MVI A,1AH
	CALL WNB
	DCR B
	JNZ ENDIT4
	LXI D,FCB3
	CALL CLSFIL
ENDALL:	JMP BOOT
;
ERMSGA:	DB	'    Errors',0DH,0AH
PCMSG:	DB	0DH,8AH
PCMSGA:	DB	'XXXXH : NEXT ADDRESS',0DH,0AH
;
ENDMSG:	DB	0DH,8AH,8AH,'Z-80 ASSEMBLY COMPLETE',0DH,8AH,0AH
;
EOFREC:	DB	':00000001FF',13,10
;
;	WOBJ - WRITE OBJECT BYTE ROUTINE
;
;	INPUT BYTE IN A REGISTER
;
WOBJ	EQU	$
	MOV B,A		;SAVE INPUT
	LDA HFLAG
	CPI 'Z'
	RZ 		;RETURN IF NO HEX FILE
	MOV A,B 	;GET INPUT CHARACTER BACK
	PUSH D
	PUSH PSW
	PUSH H
	LHLD OBJADR
	LXI D,-1
	CALL CMPHD
	POP H
	JZ WOBJ0 	;BRANCH IF FIRST TIME THROUGH
	XCHG
	LHLD OLDADR
	INX H
	CALL CMPHD
	JZ WOBJ1 	;BRA IF NEXT SEQ BYT
	CALL WREC
WOBJ0	EQU	$
	XCHG
	SHLD OBJADR
	XCHG
	XRA A
	STA OBJCNT
WOBJ1	EQU	$
	XCHG
	SHLD OLDADR
	LDA OBJCNT
	CPI 10H
	JC WOBJ2	;BRANCH IF NOT TIME TO WRITE
	CALL WREC
	LHLD OBJADR
	LXI D,16
	DAD D
	SHLD OBJADR 	;ADVANCE ADDR
	XRA A
	STA OBJCNT
WOBJ2	EQU	$
	INR A
	STA OBJCNT	;UPDATE COUNT
	DCR A
	MOV E,A
	MVI D,0
	LXI H,OBJ
	DAD D
WOBJ3:	POP PSW
	MOV M,A
	POP D
	RET
;
;	WREC - FORMAT AND WRITE HEX RECORD
;
WREC	EQU	$
	PUSH H
	PUSH D
	LHLD OLDADR
	LXI D,-1
	CALL CMPHD
	JZ WREC3 	;BRANCH IF FIRST TIME
	LDA OBJCNT
	MOV C,A
	MOV B,A 	;SET CHKSUM AND COUNT
	LXI H,REC
	MVI M,':'
	INX H
	MOV A,B
	CALL CNV2HX
	LDA OBJADR+1
	ADD C
	MOV C,A
	LDA OBJADR+1
	CALL CNV2HX
	LDA OBJADR  
	ADD C
	MOV C,A
	LDA OBJADR
	CALL CNV2HX
	XRA A
	CALL CNV2HX
	LXI D,OBJ
WREC1	EQU	$
	LDAX D
	ADD C
	MOV C,A
	LDAX D
	CALL CNV2HX
	INX D
	DCR B
	JNZ WREC1
	MOV A,C
	CMA
	INR A
	CALL CNV2HX
	MVI M,0DH
	INX H
	MVI M,0AH	;PUT CRLF ON END
	LXI H,REC	;WRITE OUT RECORD
WREC2	EQU	$
	MOV A,M
	CALL WNB2
	MOV A,M
	CPI 0AH
	INX H
	JNZ WREC2 	;GO UNTIL LF
WREC3	EQU	$
	POP D
	POP H
	RET
;
;	PLINE ROUTINE - WRITE AND PAGE
;
PLINE	EQU	$
	LDA CURLNE
	CPI MAXLNE
	JC PLINE1 	;BRANCH IF LESS
	LDA LFLAG
	CPI 'P'+1
	JNC PLINE1	;BRANCH IF NOT PRINT
	PUSH PSW	;SAVE FLAGS
	CALL HOFLNE
	POP PSW		;RECOVER FLAGS
	CALL PLINE2
	XRA A
PLINE1	EQU	$
	INR A
	STA CURLNE
	LXI H,HDRBUF
	LDA LFLAG
	CPI 'Z'
	JZ EPXIT	;SKIP PRINT, BUT SEND ERRORS
	CPI 'Y'		;ERRORS TO PRINTER ?
	PUSH PSW	;SAVE LIST FLAG
	PUSH H		;SAVE PTR LINE BUFFER
	CZ CLINE	;LISTING TO CONSOLE
	POP H		;RECOVER LINE BUFF PTR
	POP PSW		;RECOVER FLAGS
	JZ EPXIT	;ERRORS TO PRINTER
	CPI 'X'		;LIST TO CONSOLE ONLY
	JZ CLINE
PLINE2:	CPI 'P'		;LISTING TO PRINTER ?
	JNZ PRNOPT	;LISTING TO DISC .PRN FILE
	JMP WLINE	;LISTING TO PRINTER
;
PRNOPT:	PUSH H		;SAVE LINE BUFFER PTR
PRNOP:	XCHG		;LINE BUFFER TO DE
	LDAX D		;FETCH CHAR FROM LINE BUFFER
	CALL WNB	;WRITE CHAR TO PRINT BUFFER
	CPI 0AH		;WAS CHAR TERMINATOR ?
	XCHG		;REPLACE PTRS
	INX H		;INCR LINE PTR
	JNZ PRNOP	;LOOP, MORE ON LINE
	POP H		;RECOVER BUFFER PTR
	RET		;DONE
;
EPXIT:	CPI 'Z'		;SKIP LISTING ?
	JZ CLINE	;ERRORS TO CONSOLE
	LDA ERRFLG	;FETCH ERROR FLAG
	CPI ' '		;BLANK ?
	JNZ WLINE	;ERRORS TO PRINTER
	RET		;ELSE DONE
;
HOFLNE:	LXI D,FCB1+1
	LXI H,HOFNAM
	LXI B,8
	CALL MOVE 	;GET FILE NAME
	LXI H,HOFPG
	LDA PAGENO
	CALL CNV2HX
	LDA HOFPG
	CPI '0'
	JNZ $+8
	MVI A,' '
	STA HOFPG
	LDA PAGENO
	ADI 1
	DAA
	STA PAGENO
	LXI H,HOFMSG
	RET
;
HOFMSG:	DB 0CH,'Z80ASM-2.4  1982'
	DB '    SOURCE FILE NAME: '
HOFNAM:	DB 'XXXXXXXX           Page No: '
HOFPG:	DB 'XX',0DH,8AH,0AH
;
;-----------------------------------------------;
;						;
;	OPCODE TABLE MODULE			;
;						;
;-----------------------------------------------;
;
;	EACH SYMBOL TABLE ENTRY IS OF VARYING LENGTH
;
;	THE FIRST BYTE CONTAINS THE LENGTH IN THE LOWER 4 BITS
;	AND FLAGS IN THE UPPER 4 BITS.
;
;	THIS LIMITS THE MAX LENGTH OF AN ENTRY TO 15 BYTES
;
;	FOLLOWING THE FLAG/LENGTH BYTE IS THE NAME WHICH MAY BE FROM
;	1 TO 11 BYTES IN LENGTH
;
;	FOLLOWING THE NAME ARE 2 BYTES OF VALUE (LO,HI)
;	AND 1 BYTE OF TYPE (USED IN OPCODES)
;
;
;	THE TABLE IS SCANNED SEQUENTIALLY AND IS ENDED BY A 00 BYTE
;
;
;:::::::::::::::::::::::::::::::::::::::::::::::;
;						;
;	SYMBOL TABLE ADDRESS EQUATES		;
;						;
;:::::::::::::::::::::::::::::::::::::::::::::::;
;
EQUNAME	EQU	10H	;FLAG BIT - EQUATE LABEL
RNAME	EQU	20H	;FLAG BIT - REGISTER NAME
ULBL	EQU	40H	;FLAG BIT - LABEL NAME
RPNAME	EQU	80H	;FLAG BIT - REGISTER PAIR NAME
;
;SYMBEG   POINTER TO FIRST USEABLE ENTRY
;SYMCND   POINTER TO CONDITION CODE TABLE
;SYM      ACTUAL BEGINNING ADDRESS FOR SEARCHES
;
;
;	SYMBOL TABLE
;
;
SYMBEG:	DW	SYMNXT		;SYMBEG
SYMCND:	DW	CONDS		;SYMCND
SYM:	DB	7,'EXX',0D9H,0,1
	DB	7,'LDI',0EDH,0A0H,1
	DB	8,'LDIR',0EDH,0B0H,1
	DB	7,'LDD',0EDH,0A8H,1
	DB	8,'LDDR',0EDH,0B8H,1
	DB	7,'CPI',0EDH,0A1H,1
	DB	8,'CPIR',0EDH,0B1H,1
	DB	7,'CPD',0EDH,0A9H,1
	DB	8,'CPDR',0EDH,0B9H,1
	DB	7,'DAA',27H,0,1
	DB	7,'CPL',2FH,0,1
	DB	7,'NEG',0EDH,044H,1
	DB	7,'CCF',03FH,0,1
	DB	7,'SCF',037H,0,1
	DB	7,'NOP',0,0,1
	DB	8,'HALT',76H,0,1
	DB	6,'DI',0F3H,0,1
	DB	6,'EI',0FBH,0,1
	DB	6,'IM',0EDH,0FFH,1
	DB	8,'RLCA',07H,0,1
	DB	7,'RLA',17H,0,1
	DB	8,'RRCA',0FH,0,1
	DB	7,'RRA',1FH,0,1
	DB	8,'RETI',0EDH,4DH,1
	DB	8,'RETN',0EDH,45H,1
	DB	7,'INI',0EDH,0A2H,1
	DB	8,'INIR',0EDH,0B2H,1
	DB	7,'IND',0EDH,0AAH,1
	DB	8,'INDR',0EDH,0BAH,1
	DB	8,'OUTI',0EDH,0A3H,1
	DB	8,'OTIR',0EDH,0B3H,1
	DB	8,'OUTD',0EDH,0ABH,1
	DB	8,'OTDR',0EDH,0BBH,1
	DB	6,'LD',0,0,8
	DB	7,'RLC',0,0,2
	DB	6,'RL',10H,0,2
	DB	7,'RRC',8,0,2
	DB	6,'RR',18H,0,2
	DB	7,'SLA',20H,0,2
	DB	7,'SRA',28H,0,2
	DB	7,'SRL',38H,0,2
	DB	7,'RLD',0EDH,06FH,1
	DB	7,'RRD',0EDH,067H,1
	DB	8,'PUSH',0C5H,0,9
	DB	7,'POP',0C1H,0,9
	DB	6,'EX',0EBH,0,10
	DB	7,'ADD',0,9,6
	DB	7,'ADC',8,4AH,6
	DB	7,'SBC',18H,42H,6
	DB	7,'SUB',10H,0,6
	DB	7,'AND',20H,0,6
	DB	6,'OR',30H,0,6
	DB	7,'XOR',28H,0,6
	DB	6,'CP',38H,0,6
	DB	7,'INC',04H,03H,13
	DB	7,'DEC',05H,0BH,13
	DB	7,'BIT',040H,0,12
	DB	7,'SET',0C0H,0,12
	DB	7,'RES',80H,0,12
	DB	6,'JP',0C3H,0,3
	DB	8,'CALL',0CDH,0,3
	DB	6,'JR',18H,0,4
	DB	8,'DJNZ',10H,0,4
	DB	7,'RET',0C9H,0,11
	DB	7,'RST',0C7H,0,5
	DB	6,'IN',0DBH,0,7
	DB	7,'OUT',0D3H,0,7
	DB	7,'EQU',1,0,14
	DB	8,'DEFS',2,0,14
	DB	8,'DEFB',3,0,14
	DB	8,'DEFW',4,0,14
	DB	7,'END',5,0,14
	DB	7,'ORG',6,0,14
	DB	9,'EJECT',7,0,14
;
;	REGISTERS
;
	DB	5+RNAME,'A',7,0,0
	DB	5+RNAME,'B',0,0,0 
	DB	5+RNAME,'C',1,0,0
	DB	5+RNAME,'D',2,0,0
	DB	5+RNAME,'E',3,0,0
	DB	5+RNAME,'H',4,0,0
	DB	5+RNAME,'L',5,0,0
	DB	6+RPNAME,'HL',4,0,0
	DB	6+RPNAME,'BC',0,0,0
	DB	6+RPNAME,'DE',2,0,0
	DB	6+RPNAME,'SP',6,0,0
	DB	6+RPNAME,'IX',0FFH,0,0
	DB	6+RPNAME,'IY',0FEH,0,0
	DB	6,'AF',06H,0,0	;FOR PUSH/POP
CONDS	EQU	$
	DB	5,'Z',1,0,0
	DB	6,'NZ',0,0,0
	DB	5,'C',3,0,0
	DB	6,'NC',2,0,0
	DB	6,'PO',4,0,0
	DB	6,'PE',5,0,0
	DB	5,'P',6,0,0
	DB	5,'M',7,0,0
SYMNXT	EQU	$		;FIRST AVAILABLE SLOT
	DB	0
END
